🖕欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。 

（手机横屏看源码更方便）

---
## 问题（选自经典面试题）
1. 几种常见的线程池有哪些，以及他们的使用场景
2. 线程池都有哪几种工作队列
3. 简单的描述一下线程池的工作原理

## 简介
**线程池** 是一种线程使用模式，同时也是一种池化技术。在java中，类似的池化技术有很多，例如jvm的String常量池，数据库连接池。
如果把此逻辑进行拓展，甚至连单例模式或者redis缓存也算是一种池化技术。而池化技术最初的目的，就是减少计算机的资源消耗。

JDK中的关于**并行执行任务的框架**主要有两个 Executor框架 和 fork-join框架 本章先拿Executor框架开刀。

对于Executor框架而言，最核心的就是ThreadPoolExecutor类。JDK提供的四大默认线程池就是由此类提供支持。

## 一个线程池的小例子
````
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TestThreadPool {

    public static void main(String[] args) {
        //初始化ThreadPoolExecutor类，这里给ThreadPoolExecutor类提供很多很多参数
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5));

        for(int i=0;i<12;i++){
            //定义了一个任务
            Task task = new Task(i);
            //往这个池进行提交任务，可以把这个池当成一个工人，“把一个完完整整的活丢给了一个工人”
            executor.execute(task);
            //打印一些线程池的信息，就单纯的查看一下
            System.out.println("线程池中线程数目："+executor.getPoolSize()+"，队列中等待执行的任务数目："+ executor.getQueue().size()+"，已执行的任务数目："+executor.getCompletedTaskCount());
        }
        //关闭线程池，不再接受submit
        executor.shutdown();
    }
}


class Task implements Runnable {
    private int num;

    public Task(int num) {
        this.num = num;
    }
    @Override
    public void run() {
        System.out.println("正在执行task "+num);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task "+num+"执行完毕");
    }
}
````

从这个最基础的场景类可以看出，线程池的一般运作方式有

1. 初始化线程池，通过参数配置线程池的各种行为
2. 往线程池内提交task
3. 关闭线程池

那么接下来就一步一步的进入到ThreadPoolExecutor内部查看到底这个类是怎么运作的

## 之后的小节的目录大纲

1. ThreadPoolExecutor的继承关系图，重要父类，接口的关系，一些重要方法
2. ThreadPoolExecutor类的重要field
       + 线程池的状态相关field
       + 线程池的执行方法相关field
       + 线程池的辅助性支持field与inner class
3. ThreadPoolExecutor类构造方法
4. ThreadPoolExecutor类的核心方法(核心逻辑)
       + 线程池内线程初始化
       + 线程池的线程提交
       + 线程池的任务缓存队列及排队策略
       + 线程池的任务拒绝策略
       + 线程池容量的动态调整
5. 线程池的关闭
6. ThreadPoolExecutor类和JDK提供的四个线程池关系
6. 全量源码注释

## 1. ThreadPoolExecutor的继承关系图

从图内可以大致知道这样的继承关系

1. Executor是一个顶层接口，打开这个接口后发现只有一个方法,此方法就是用来执行传进去的任务的
````
public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     * 1. 执行给定的指令(Runnable 实现类)
     * 2. 此指令将会在新开线程内,线程池内,带有返回的线程内执行
     */
    void execute(Runnable command);
}
````
2. 接下来ExecutorService接口继承了Executor接口，打开并摘取一部分重要的方法
````
public interface ExecutorService extends Executor {
    // 线程池关闭，线程池里的线程就随它去
    void shutdown();
    
    //立刻停止！马上！正在执行的给我立马停！那些个没执行的返回来
    List<Runnable> shutdownNow();
    
    //判断线程池是不是被停了
    boolean isShutdown();

    //判断关闭（调用shutdown方法之后）线程池里面的线程是不是执行完了
    boolean isTerminated();

    //调用此方法之后就一直等待着线程池里面的线程执行完了之后，才能继续，两个参数控制等待的行为
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

     //好重要好重要的一个方法，用来提交有返回值的线程
    <T> Future<T> submit(Callable<T> task);

    //提交一个线程，指定一个结果，当线程完成的时候返回自定义的结果
    //相当于submit(Callable<T> task) 的另外一种实现
    <T> Future<T> submit(Runnable task, T result);

    //提交一个runnable 的线程，执行完了就返回null(Future.get()之后返回)
    //是不是觉得没啥意义~~意义当然有
    //返回的是一个Future，当调用get(),代码就会卡在那，等着返回
    //返回的即是是null,我也不care，目的只有“我知道这个任务已经结束了，可以开始下面的事情了”
    Future<?> submit(Runnable task);

    //相当于批量的submit(Callable<T> task)方法，一口气把想执行的callable task丢进线程池里面
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    //在批量提交的方法上增加时间相关的参数
    //如果超时，那么list里面的某个任务会被取消
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    //提交一大堆的线程，这么多线程里面一个成功就可以，只要给我一个返回值
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    //这个道理类似，就是在invokeAny(Collection<? extends Callable<T>> tasks) 上增加时间的控制
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
````
3. 那么再然后就是

