ğŸ–•æ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å·â€œå½¤å“¥è¯»æºç â€ï¼ŒæŸ¥çœ‹æ›´å¤šæºç ç³»åˆ—æ–‡ç« , ä¸å½¤å“¥ä¸€èµ·ç•…æ¸¸æºç çš„æµ·æ´‹ã€‚ 

ï¼ˆæ‰‹æœºæ¨ªå±çœ‹æºç æ›´æ–¹ä¾¿ï¼‰

---
## é—®é¢˜ï¼ˆé€‰è‡ªç»å…¸é¢è¯•é¢˜ï¼‰
1. å‡ ç§å¸¸è§çš„çº¿ç¨‹æ± æœ‰å“ªäº›ï¼Œä»¥åŠä»–ä»¬çš„ä½¿ç”¨åœºæ™¯
2. çº¿ç¨‹æ± éƒ½æœ‰å“ªå‡ ç§å·¥ä½œé˜Ÿåˆ—
3. ç®€å•çš„æè¿°ä¸€ä¸‹çº¿ç¨‹æ± çš„å·¥ä½œåŸç†

## ç®€ä»‹
**çº¿ç¨‹æ± ** æ˜¯ä¸€ç§çº¿ç¨‹ä½¿ç”¨æ¨¡å¼ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ç§æ± åŒ–æŠ€æœ¯ã€‚åœ¨javaä¸­ï¼Œç±»ä¼¼çš„æ± åŒ–æŠ€æœ¯æœ‰å¾ˆå¤šï¼Œä¾‹å¦‚jvmçš„Stringå¸¸é‡æ± ï¼Œæ•°æ®åº“è¿æ¥æ± ã€‚
å¦‚æœæŠŠæ­¤é€»è¾‘è¿›è¡Œæ‹“å±•ï¼Œç”šè‡³è¿å•ä¾‹æ¨¡å¼æˆ–è€…redisç¼“å­˜ä¹Ÿç®—æ˜¯ä¸€ç§æ± åŒ–æŠ€æœ¯ã€‚è€Œæ± åŒ–æŠ€æœ¯æœ€åˆçš„ç›®çš„ï¼Œå°±æ˜¯å‡å°‘è®¡ç®—æœºçš„èµ„æºæ¶ˆè€—ã€‚

JDKä¸­çš„å…³äº**å¹¶è¡Œæ‰§è¡Œä»»åŠ¡çš„æ¡†æ¶**ä¸»è¦æœ‰ä¸¤ä¸ª Executoræ¡†æ¶ å’Œ fork-joinæ¡†æ¶ æœ¬ç« å…ˆæ‹¿Executoræ¡†æ¶å¼€åˆ€ã€‚

å¯¹äºExecutoræ¡†æ¶è€Œè¨€ï¼Œæœ€æ ¸å¿ƒçš„å°±æ˜¯ThreadPoolExecutorç±»ã€‚JDKæä¾›çš„å››å¤§é»˜è®¤çº¿ç¨‹æ± å°±æ˜¯ç”±æ­¤ç±»æä¾›æ”¯æŒã€‚

## ä¸€ä¸ªçº¿ç¨‹æ± çš„å°ä¾‹å­
```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TestThreadPool {

    public static void main(String[] args) {
        //åˆå§‹åŒ–ThreadPoolExecutorç±»ï¼Œè¿™é‡Œç»™ThreadPoolExecutorç±»æä¾›å¾ˆå¤šå¾ˆå¤šå‚æ•°
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5));

        for(int i=0;i<12;i++){
            //å®šä¹‰äº†ä¸€ä¸ªä»»åŠ¡
            Task task = new Task(i);
            //å¾€è¿™ä¸ªæ± è¿›è¡Œæäº¤ä»»åŠ¡ï¼Œå¯ä»¥æŠŠè¿™ä¸ªæ± å½“æˆä¸€ä¸ªå·¥äººï¼Œâ€œæŠŠä¸€ä¸ªå®Œå®Œæ•´æ•´çš„æ´»ä¸¢ç»™äº†ä¸€ä¸ªå·¥äººâ€
            executor.execute(task);
            //æ‰“å°ä¸€äº›çº¿ç¨‹æ± çš„ä¿¡æ¯ï¼Œå°±å•çº¯çš„æŸ¥çœ‹ä¸€ä¸‹
            System.out.println("çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ç›®ï¼š"+executor.getPoolSize()+"ï¼Œé˜Ÿåˆ—ä¸­ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡æ•°ç›®ï¼š"+ executor.getQueue().size()+"ï¼Œå·²æ‰§è¡Œçš„ä»»åŠ¡æ•°ç›®ï¼š"+executor.getCompletedTaskCount());
        }
        //å…³é—­çº¿ç¨‹æ± ï¼Œä¸å†æ¥å—submit
        executor.shutdown();
    }
}


class Task implements Runnable {
    private int num;

    public Task(int num) {
        this.num = num;
    }
    @Override
    public void run() {
        System.out.println("æ­£åœ¨æ‰§è¡Œtask "+num);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task "+num+"æ‰§è¡Œå®Œæ¯•");
    }
}
```

ä»è¿™ä¸ªæœ€åŸºç¡€çš„åœºæ™¯ç±»å¯ä»¥çœ‹å‡ºï¼Œçº¿ç¨‹æ± çš„ä¸€èˆ¬è¿ä½œæ–¹å¼æœ‰

1. åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œé€šè¿‡å‚æ•°é…ç½®çº¿ç¨‹æ± çš„å„ç§è¡Œä¸º
2. å¾€çº¿ç¨‹æ± å†…æäº¤task
3. å…³é—­çº¿ç¨‹æ± 

é‚£ä¹ˆæ¥ä¸‹æ¥å°±ä¸€æ­¥ä¸€æ­¥çš„è¿›å…¥åˆ°ThreadPoolExecutorå†…éƒ¨æŸ¥çœ‹åˆ°åº•è¿™ä¸ªç±»æ˜¯æ€ä¹ˆè¿ä½œçš„

## ä¹‹åçš„å°èŠ‚çš„ç›®å½•å¤§çº²

1. ThreadPoolExecutorçš„ç»§æ‰¿å…³ç³»å›¾ï¼Œé‡è¦çˆ¶ç±»ï¼Œæ¥å£çš„å…³ç³»ï¼Œä¸€äº›é‡è¦æ–¹æ³•
2. ThreadPoolExecutorç±»çš„é‡è¦field
       + çº¿ç¨‹æ± çš„çŠ¶æ€ç›¸å…³field
       + çº¿ç¨‹æ± çš„æ‰§è¡Œæ–¹æ³•ç›¸å…³çš„æ ¸å¿ƒfield
       + çº¿ç¨‹æ± çš„è¾…åŠ©æ€§æ”¯æŒfieldä¸inner class
3. ThreadPoolExecutorç±»æ„é€ æ–¹æ³•
4. ThreadPoolExecutorç±»çš„æ ¸å¿ƒæ–¹æ³•(æ ¸å¿ƒé€»è¾‘)
       + çº¿ç¨‹æ± çš„çº¿ç¨‹æäº¤
       + çº¿ç¨‹æ± å†…çº¿ç¨‹åˆå§‹åŒ–
       + çº¿ç¨‹æ± çš„ä»»åŠ¡ç¼“å­˜é˜Ÿåˆ—åŠæ’é˜Ÿç­–ç•¥
       + çº¿ç¨‹æ± çš„ä»»åŠ¡æ‹’ç»ç­–ç•¥
       + çº¿ç¨‹æ± å®¹é‡çš„åŠ¨æ€è°ƒæ•´
5. çº¿ç¨‹æ± çš„å…³é—­
6. ThreadPoolExecutorç±»å’ŒJDKæä¾›çš„å››ä¸ªçº¿ç¨‹æ± å…³ç³»
6. å…¨é‡æºç æ³¨é‡Š

## 1. ThreadPoolExecutorçš„ç»§æ‰¿å…³ç³»å›¾

ä»å›¾å†…å¯ä»¥å¤§è‡´çŸ¥é“è¿™æ ·çš„ç»§æ‰¿å…³ç³»

1. Executoræ˜¯ä¸€ä¸ªé¡¶å±‚æ¥å£ï¼Œæ‰“å¼€è¿™ä¸ªæ¥å£åå‘ç°åªæœ‰ä¸€ä¸ªæ–¹æ³•,æ­¤æ–¹æ³•å°±æ˜¯ç”¨æ¥æ‰§è¡Œä¼ è¿›å»çš„ä»»åŠ¡çš„
```java
public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     * 1. æ‰§è¡Œç»™å®šçš„æŒ‡ä»¤(Runnable å®ç°ç±»)
     * 2. æ­¤æŒ‡ä»¤å°†ä¼šåœ¨æ–°å¼€çº¿ç¨‹å†…,çº¿ç¨‹æ± å†…,å¸¦æœ‰è¿”å›çš„çº¿ç¨‹å†…æ‰§è¡Œ
     */
    void execute(Runnable command);
}
```
2. æ¥ä¸‹æ¥ExecutorServiceæ¥å£ç»§æ‰¿äº†Executoræ¥å£ï¼Œæ‰“å¼€å¹¶æ‘˜å–ä¸€éƒ¨åˆ†é‡è¦çš„æ–¹æ³•
```java
public interface ExecutorService extends Executor {
    // çº¿ç¨‹æ± å…³é—­ï¼Œçº¿ç¨‹æ± é‡Œçš„çº¿ç¨‹å°±éšå®ƒå»
    void shutdown();
    
    //ç«‹åˆ»åœæ­¢ï¼é©¬ä¸Šï¼æ­£åœ¨æ‰§è¡Œçš„ç»™æˆ‘ç«‹é©¬åœï¼é‚£äº›ä¸ªæ²¡æ‰§è¡Œçš„è¿”å›æ¥
    List<Runnable> shutdownNow();
    
    //åˆ¤æ–­çº¿ç¨‹æ± æ˜¯ä¸æ˜¯è¢«åœäº†
    boolean isShutdown();

    //åˆ¤æ–­å…³é—­ï¼ˆè°ƒç”¨shutdownæ–¹æ³•ä¹‹åï¼‰çº¿ç¨‹æ± é‡Œé¢çš„çº¿ç¨‹æ˜¯ä¸æ˜¯æ‰§è¡Œå®Œäº†
    boolean isTerminated();

    //è°ƒç”¨æ­¤æ–¹æ³•ä¹‹åå°±ä¸€ç›´ç­‰å¾…ç€çº¿ç¨‹æ± é‡Œé¢çš„çº¿ç¨‹æ‰§è¡Œå®Œäº†ä¹‹åï¼Œæ‰èƒ½ç»§ç»­ï¼Œä¸¤ä¸ªå‚æ•°æ§åˆ¶ç­‰å¾…çš„è¡Œä¸º
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

     //å¥½é‡è¦å¥½é‡è¦çš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨æ¥æäº¤æœ‰è¿”å›å€¼çš„çº¿ç¨‹
    <T> Future<T> submit(Callable<T> task);

    //æäº¤ä¸€ä¸ªçº¿ç¨‹ï¼ŒæŒ‡å®šä¸€ä¸ªç»“æœï¼Œå½“çº¿ç¨‹å®Œæˆçš„æ—¶å€™è¿”å›è‡ªå®šä¹‰çš„ç»“æœ
    //ç›¸å½“äºsubmit(Callable<T> task) çš„å¦å¤–ä¸€ç§å®ç°
    <T> Future<T> submit(Runnable task, T result);

    //æäº¤ä¸€ä¸ªrunnable çš„çº¿ç¨‹ï¼Œæ‰§è¡Œå®Œäº†å°±è¿”å›null(Future.get()ä¹‹åè¿”å›)
    //æ˜¯ä¸æ˜¯è§‰å¾—æ²¡å•¥æ„ä¹‰~~æ„ä¹‰å½“ç„¶æœ‰
    //è¿”å›çš„æ˜¯ä¸€ä¸ªFutureï¼Œå½“è°ƒç”¨get(),ä»£ç å°±ä¼šå¡åœ¨é‚£ï¼Œç­‰ç€è¿”å›
    //è¿”å›çš„å³æ˜¯æ˜¯null,æˆ‘ä¹Ÿä¸careï¼Œç›®çš„åªæœ‰â€œæˆ‘çŸ¥é“è¿™ä¸ªä»»åŠ¡å·²ç»ç»“æŸäº†ï¼Œå¯ä»¥å¼€å§‹ä¸‹é¢çš„äº‹æƒ…äº†â€
    Future<?> submit(Runnable task);

    //ç›¸å½“äºæ‰¹é‡çš„submit(Callable<T> task)æ–¹æ³•ï¼Œä¸€å£æ°”æŠŠæƒ³æ‰§è¡Œçš„callable taskä¸¢è¿›çº¿ç¨‹æ± é‡Œé¢
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    //åœ¨æ‰¹é‡æäº¤çš„æ–¹æ³•ä¸Šå¢åŠ æ—¶é—´ç›¸å…³çš„å‚æ•°
    //å¦‚æœè¶…æ—¶ï¼Œé‚£ä¹ˆlisté‡Œé¢çš„æŸä¸ªä»»åŠ¡ä¼šè¢«å–æ¶ˆ
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    //æäº¤ä¸€å¤§å †çš„çº¿ç¨‹ï¼Œè¿™ä¹ˆå¤šçº¿ç¨‹é‡Œé¢ä¸€ä¸ªæˆåŠŸå°±å¯ä»¥ï¼Œåªè¦ç»™æˆ‘ä¸€ä¸ªè¿”å›å€¼
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    //è¿™ä¸ªé“ç†ç±»ä¼¼ï¼Œå°±æ˜¯åœ¨invokeAny(Collection<? extends Callable<T>> tasks) ä¸Šå¢åŠ æ—¶é—´çš„æ§åˆ¶
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```
3. é‚£ä¹ˆå†ç„¶åå°±æ˜¯AbstractExecutorService è¿™ä¸ªç±»åŸºæœ¬ä¸Šå®ç°äº†ExecutorServiceçš„è¡Œä¸ºï¼Œå…·ä½“å†ç»†èŠ‚çš„ä¸œè¥¿æˆ‘ä»¬åœ¨ä»–çš„å­ç±»é‡Œé¢è¯¦ç»†çš„è¯´
è¯·è®°ä½è¿™ä¸ªç”·äºº Doug Lea ï¼è¿™ä¸ªç±»å°±æ˜¯è¿™ä¸ªäººå†™çš„
4. æœ€é‡è¦çš„å‹è½´ç±»å°±æ˜¯ThreadPoolExecutorï¼Œè¿™ä¸ªç±»ç»§æ‰¿äº†AbstractExecutorServiceç±»

## 2. ThreadPoolExecutorç±»çš„é‡è¦field

ThreadPoolExecutorç±» æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„ç±»ï¼Œé‡Œé¢çš„è¡Œä¸ºé€»è¾‘çº¿æ¡å¾ˆå¤šï¼Œå› æ­¤åœ¨åæœŸçš„è¯´æ˜ä¸­ä¼šè¾…ä»¥å¤§é‡çš„æµç¨‹å›¾è¿›è¡Œè¡¨ç¤ºã€‚

ç±»çš„fieldçš„æ•°é‡ä¹Ÿå¤šçš„å“äººï¼Œå› æ­¤åœ¨é€»è¾‘ä¸Šæˆ‘ä»¬å…ˆå°†å…¨éƒ¨çš„æ ¸å¿ƒé€»è¾‘ç›¸å…³çš„fieldæŒ‰ç…§åŠŸèƒ½è¿›è¡Œåˆ’åˆ†ï¼Œä¸€ä¸€å‡»ç ´å³å¯ã€‚

### æŒ‰ç…§åŠŸèƒ½åˆ’åˆ†-çº¿ç¨‹æ± çš„çŠ¶æ€

 é¦–å…ˆå¥‰ä¸Šå„ç§çº¿ç¨‹æ± çŠ¶æ€çš„è¿ç§»å›¾åŠå…¶å…³ç³»

```java
    //AQSåˆ™åªæä¾›äº†stateä¸€ä¸ªintå‹å˜é‡ï¼Œæ­¤æ—¶å°†stateé«˜16ä½è¡¨ç¤ºä¸ºè¯»çŠ¶æ€ï¼Œä½16ä½è¡¨ç¤ºä¸ºå†™çŠ¶æ€ã€‚è¿™é‡Œçš„cltåŒæ ·ä¹Ÿæ˜¯ï¼Œå®ƒè¡¨ç¤ºäº†ä¸¤ä¸ªæ¦‚å¿µï¼š
    //1. workerCountï¼šå½“å‰æœ‰æ•ˆçš„çº¿ç¨‹æ•°
    //2. runStateï¼šå½“å‰çº¿ç¨‹æ± çš„äº”ç§çŠ¶æ€ï¼ŒRunningã€Shutdownã€Stopã€Tidyingã€Terminateã€‚
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
        //c & é«˜3ä½ä¸º1ï¼Œä½29ä½ä¸º0çš„~CAPACITYï¼Œç”¨äºè·å–é«˜3ä½ä¿å­˜çš„çº¿ç¨‹æ± çŠ¶æ€
    private static int runStateOf(int c)     { return c & ~CAPACITY; }
    //c & é«˜3ä½ä¸º0ï¼Œä½29ä½ä¸º1çš„CAPACITYï¼Œç”¨äºè·å–ä½29ä½çš„çº¿ç¨‹æ•°é‡
    private static int workerCountOf(int c)  { return c & CAPACITY; }
    //å‚æ•°rsè¡¨ç¤ºrunStateï¼Œå‚æ•°wcè¡¨ç¤ºworkerCountï¼Œå³æ ¹æ®runStateå’ŒworkerCountæ‰“åŒ…åˆå¹¶æˆctl
    private static int ctlOf(int rs, int wc) { return rs | wc; }


    private static final int CAPACITY = (1 << COUNT_BITS) â€“ 1;    //ä½29ä½è¡¨ç¤ºæœ€å¤§çº¿ç¨‹æ•°ï¼Œ229-1
    //å®šä¸€ä¸ªå¸¸é‡ï¼Œåœ¨ä¹‹åå®šä¹‰çŠ¶æ€å€¼æ˜¯ä½¿ç”¨
    private static final int COUNT_BITS = Integer.SIZE - 3;         //32-3=29ï¼Œçº¿ç¨‹æ•°é‡æ‰€å ä½æ•°

    //çº¿ç¨‹æ± å¤„åœ¨RUNNINGçŠ¶æ€æ—¶ï¼Œèƒ½å¤Ÿæ¥æ”¶æ–°ä»»åŠ¡ï¼Œä»¥åŠå¯¹å·²æ·»åŠ çš„ä»»åŠ¡è¿›è¡Œå¤„ç†ã€‚
    //çº¿ç¨‹æ± çš„åˆå§‹åŒ–çŠ¶æ€æ˜¯RUNNINGã€‚å½“çº¿ç¨‹æ± è¢«ä¸€æ—¦è¢«åˆ›å»ºï¼Œå°±å¤„äºRUNNINGçŠ¶æ€ï¼Œè¿™ä¸ªæ—¶å€™çº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡æ•°ä¸º0
    private static final int RUNNING    = -1 << COUNT_BITS; // intå‹å˜é‡é«˜3ä½ï¼ˆå«ç¬¦å·ä½ï¼‰101è¡¨RUNING

    //å¦‚æœè°ƒç”¨äº†shutdown()æ–¹æ³•ï¼Œåˆ™çº¿ç¨‹æ± å¤„äºSHUTDOWNçŠ¶æ€
    //çº¿ç¨‹æ± å¤„åœ¨SHUTDOWNçŠ¶æ€æ—¶ï¼Œä¸æ¥æ”¶æ–°ä»»åŠ¡ï¼Œä½†èƒ½å¤„ç†å·²æ·»åŠ çš„ä»»åŠ¡ã€‚
    private static final int SHUTDOWN   =  0 << COUNT_BITS; //é«˜3ä½000

    //å¦‚æœè°ƒç”¨äº†shutdownNow()æ–¹æ³•ï¼Œåˆ™çº¿ç¨‹æ± å¤„äºSTOPçŠ¶æ€
    //çº¿ç¨‹æ± å¤„åœ¨STOPçŠ¶æ€æ—¶ï¼Œä¸æ¥æ”¶æ–°ä»»åŠ¡ï¼Œä¸å¤„ç†å·²æ·»åŠ çš„ä»»åŠ¡ï¼Œå¹¶ä¸”ä¼šä¸­æ–­æ­£åœ¨å¤„ç†çš„ä»»åŠ¡ã€‚
    private static final int STOP       =  1 << COUNT_BITS; ////é«˜3ä½001

    //å½“æ‰€æœ‰çš„ä»»åŠ¡å·²ç»ˆæ­¢ï¼Œå½“å‰ç±»è®°å½•çš„â€ä»»åŠ¡æ•°é‡â€ä¸º0ï¼Œçº¿ç¨‹æ± ä¼šå˜ä¸ºTIDYINGçŠ¶æ€ã€‚å½“çº¿ç¨‹æ± å˜ä¸ºTIDYINGçŠ¶æ€æ—¶ï¼Œä¼šæ‰§è¡Œé’©å­å‡½æ•°terminated()
    private static final int TIDYING    =  2 << COUNT_BITS; //é«˜3ä½010

    //çº¿ç¨‹æ± å½»åº•ç»ˆæ­¢ï¼Œå°±å˜æˆTERMINATEDçŠ¶æ€ã€‚ 
    private static final int TERMINATED =  3 << COUNT_BITS; //é«˜3ä½011


```

### çº¿ç¨‹æ± çš„æ‰§è¡Œæ–¹æ³•ç›¸å…³çš„æ ¸å¿ƒfield
è¿˜æ˜¯å…ˆç¥­å‡ºä¸€æ³¢æ‰€æœ‰çš„fieldåˆ—è¡¨
åœ¨è¿™é‡Œé¢æˆ‘ä»¬æŒ‘é€‰é‡è¦çš„æˆå‘˜å˜é‡è¿›è¡Œè¯´æ˜
```java
    //ä»¥ä¸‹6ä¸ªæˆå‘˜å˜é‡ç›´æ¥ç”±æ„é€ æ–¹æ³•ä¼ å…¥
    //æ ¸å¿ƒæ± çš„å¤§å°ï¼Œå½“çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°ç›®å¤§äºè¿™ä¸ªå‚æ•°æ—¶ï¼Œæäº¤çš„ä»»åŠ¡ä¼šè¢«æ”¾è¿›ä»»åŠ¡ç¼“å­˜é˜Ÿåˆ—
    private volatile int corePoolSize;                  //1
    private volatile int maximumPoolSize;               //2 çº¿ç¨‹æ± æœ€å¤§èƒ½å®¹å¿çš„çº¿ç¨‹æ•°
    private final BlockingQueue<Runnable> workQueue;    //3 ä»»åŠ¡ç¼“å­˜é˜Ÿåˆ—ï¼Œç”¨æ¥å­˜æ”¾ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡
    private volatile long keepAliveTime;                //4 çº¿ç¨‹å­˜æ´»æ—¶é—´
    private volatile ThreadFactory threadFactory;       //5 çº¿ç¨‹å·¥å‚ï¼Œç”¨æ¥åˆ›å»ºçº¿ç¨‹
    private volatile RejectedExecutionHandler handler;  //6 ä»»åŠ¡æ‹’ç»ç­–ç•¥

    private long completedTaskCount;        //ç”¨æ¥è®°å½•å·²ç»æ‰§è¡Œå®Œæ¯•çš„ä»»åŠ¡ä¸ªæ•°
    private volatile int   poolSize;        //çº¿ç¨‹æ± ä¸­å½“å‰çš„çº¿ç¨‹æ•°
    private volatile boolean allowCoreThreadTimeOut;   //æ˜¯å¦å…è®¸ä¸ºæ ¸å¿ƒçº¿ç¨‹è®¾ç½®å­˜æ´»æ—¶é—´
    private final HashSet<Worker> workers = new HashSet<Worker>();  //ç”¨æ¥å­˜æ”¾å·¥ä½œé›†
    private final ReentrantLock mainLock = new ReentrantLock();     //çº¿ç¨‹æ± çš„ä¸»è¦çŠ¶æ€é” å¾ˆå¤šæ–¹æ³•å¼ºçƒˆä¾èµ–äºè¿™ä¸ªé”

```

### çº¿ç¨‹æ± çš„è¾…åŠ©æ€§æ”¯æŒfieldä¸inner class,ä¸€äº›ç›¸å…³çš„æ–¹æ³•
```java


//ç”¨æ¥å­˜æ”¾å·¥ä½œé›†
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {...}
//ä»¥ä¸‹å››ä¸ªinnerç±»å¯ä»¥è§‚å¯Ÿåˆ°éƒ½å®ç°äº†RejectedExecutionHandleræ¥å£ï¼Œè¿™å°±æ˜¯æ‹’ç»ç­–ç•¥å®ä½“ç±»
//æ˜¯ç›´æ¥å®šä¹‰åˆ°ThreadPoolExecutorç±»å†…çš„
public static class CallerRunsPolicy implements RejectedExecutionHandler {...}
public static class AbortPolicy implements RejectedExecutionHandler {...}
public static class DiscardPolicy implements RejectedExecutionHandler {...}
public static class DiscardOldestPolicy implements RejectedExecutionHandler {...}
```

## ThreadPoolExecutorç±»æ„é€ æ–¹æ³•
ThreadPoolExecutorç±»æ„é€ æ–¹æ³• çš„æ„é€ æ–¹æ³•æ€»å…±æœ‰å››ä¸ªï¼Œæœ‰äº›å‚æ•°å¯ä»¥ç¼ºçœï¼Œé‚£ä¹ˆå°±ç”¨é»˜è®¤çš„ä»£æ›¿ï¼Œæœ€ç»ˆè°ƒç”¨çš„å°±æ˜¯ä¸‹é¢æ‰€çœ‹åˆ°çš„æ„é€ æ–¹æ³•
```java
    // è¿™äº›å‚æ•°ä»£è¡¨ä»€ä¹ˆå·²ç»åœ¨ä¸Šä¸ªå°èŠ‚å†…å¨å¨è¿‡äº†ï¼Œåœ¨æ­¤ä¸å†é‡å¤ï¼Œåªå…³å¿ƒæ„é€ å‡½æ•°å†…çš„é€»è¾‘
    // ThreadFactory å¯ä»¥ç¼ºçœï¼Œä»£æ›¿ä¸ºExecutors.defaultThreadFactory()
    // RejectedExecutionHandler å¯ä»¥ç¼ºçœ ä»£æ›¿ä¸º ThreadPoolExecutor.defaultHandler(å†…éƒ¨ç±»AbortPolicyçš„å®ä¾‹)
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,
                              TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        /**
         * 1. æ£€æŸ¥æ•°å€¼å‹çš„å…¥å‚æ˜¯å¦ç¬¦åˆè¦æ±‚
         * 2. æ£€æŸ¥å¼•ç”¨ç±»å‹å…¥å‚æ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œåªè¦ä¸€ä¸ªnullå°±æŠ›å¼‚å¸¸
         * 3. è¯¥èµ‹å€¼çš„å°±èµ‹å€¼ï¼Œå„å›å„å®¶ï¼Œå„æ‰¾çˆ¹å¦ˆ
         * 4. keepAliveTime é€šè¿‡TimeUnit(æ—¶é—´ç±»å‹)å’Œ keepAliveTime(æ—¶é—´æ•°å€¼)æœ€ç»ˆç¡®å®šæ ‡å‡†ç±»å‹çš„æ—¶é—´é•¿åº¦
         * */
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
## 3. ThreadPoolExecutorç±»çš„æ ¸å¿ƒæ–¹æ³•(æ ¸å¿ƒé€»è¾‘)
### æäº¤ä»»åŠ¡
ä»ExecutorServiceæ¥å£å®šä¹‰å¯ä»¥å‘ç°ï¼Œæäº¤ä»»åŠ¡çš„æ–¹å¼æ˜¯æœ‰å¾ˆå¤šçš„ï¼Œç„¶è€Œæœ€ç»ˆéƒ½å’Œé¡¶çº§æ¥å£å®šä¹‰çš„execute()æ–¹æ³•åˆ†ä¸å¼€

å› æ­¤æˆ‘ä»¬ä»¥è¿™ä¸ªä¸ºçªç ´å£ï¼Œåˆšå¥½ï¼Œå‰é¢å°èŠ‚å†…æä¾›çš„å°æ¡ˆä¾‹å°±æ˜¯ä½¿ç”¨execute()æ–¹æ³•æäº¤çš„ä»»åŠ¡
```java
public void execute(Runnable command) {
        // å¦‚æœä¼ å…¥ä¸ºç©ºï¼Œåˆ™æŠ›å¼‚å¸¸
        if (command == null)
            throw new NullPointerException();
        ////ç”±å®ƒå¯ä»¥è·å–åˆ°å½“å‰æœ‰æ•ˆçš„çº¿ç¨‹æ•°å’Œçº¿ç¨‹æ± çš„çŠ¶æ€
        int c = ctl.get();
        //è·å–å½“å‰æ­£åœ¨è¿è¡Œçº¿ç¨‹æ•°æ˜¯å¦å°äºæ ¸å¿ƒçº¿ç¨‹æ± ï¼Œæ˜¯åˆ™æ–°åˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œå¦åˆ™å°†ä»»åŠ¡æ”¾åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­
        //æ–°å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œèµ‹ç»™workerå®ä¾‹ï¼Œworkerçº¿ç¨‹è°ƒç”¨commandçš„runæ–¹æ³•
        if (workerCountOf(c) < corePoolSize) { 
            //åœ¨addWorkerä¸­åˆ›å»ºå·¥ä½œçº¿ç¨‹æ‰§è¡Œä»»åŠ¡
            if (addWorker(command, true))             //.....addWorkeræ–¹æ³• 
                return;
            c = ctl.get();
        }
        //å½“å‰æ ¸å¿ƒçº¿ç¨‹æ± ä¸­å…¨éƒ¨çº¿ç¨‹éƒ½åœ¨è¿è¡Œ -> workerCountOf(c) >= corePoolSizeï¼Œæ‰€ä»¥æ­¤æ—¶å°†çº¿ç¨‹æ”¾åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­
        //çº¿ç¨‹æ± æ˜¯å¦å¤„äºè¿è¡ŒçŠ¶æ€ï¼Œä¸”æ˜¯å¦ä»»åŠ¡æ’å…¥ä»»åŠ¡é˜Ÿåˆ—æˆåŠŸ
        if (isRunning(c) && workQueue.offer(command)) { //workQueue.offer 
            int recheck = ctl.get();
            //çº¿ç¨‹æ± æ˜¯å¦å¤„äºè¿è¡ŒçŠ¶æ€ï¼Œå¦‚æœä¸æ˜¯åˆ™ä½¿åˆšåˆšçš„ä»»åŠ¡å‡ºé˜Ÿ
            if (! isRunning(recheck) && remove(command))
                //æŠ›å‡ºRejectedExceptionExceptionå¼‚å¸¸
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //æ’å…¥é˜Ÿåˆ—ä¸æˆåŠŸï¼Œä¸”å½“å‰çº¿ç¨‹æ•°æ•°é‡å°äºæœ€å¤§çº¿ç¨‹æ± æ•°é‡ï¼Œæ­¤æ—¶åˆ™åˆ›å»ºæ–°çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œåˆ›å»ºå¤±è´¥æŠ›å‡ºå¼‚å¸¸
        else if (!addWorker(command, false))
            //æŠ›å‡ºRejectedExceptionExceptionå¼‚å¸¸
            reject(command);
    }
```
æµç¨‹ä¸»é€»è¾‘æœ‰ï¼š

1. å¦‚æœçº¿ç¨‹æ± å½“å‰çº¿ç¨‹æ•°é‡å°‘äºcorePoolSizeï¼Œåˆ™addWorker(command, true)åˆ›å»ºæ–°workerçº¿ç¨‹ï¼Œå¦‚åˆ›å»ºæˆåŠŸè¿”å›ï¼Œå¦‚æ²¡åˆ›å»ºæˆåŠŸï¼Œåˆ™æ‰§è¡Œåç»­æ­¥éª¤ï¼›
    addWorker(command, true)å¤±è´¥çš„åŸå› å¯èƒ½æ˜¯ï¼š
    Aã€çº¿ç¨‹æ± å·²ç»shutdownï¼Œshutdownçš„çº¿ç¨‹æ± ä¸å†æ¥æ”¶æ–°ä»»åŠ¡
    Bã€workerCountOf(c) < corePoolSize åˆ¤æ–­åï¼Œç”±äºå¹¶å‘ï¼Œåˆ«çš„çº¿ç¨‹å…ˆåˆ›å»ºäº†workerçº¿ç¨‹ï¼Œå¯¼è‡´workerCount>=corePoolSize
2. å¦‚æœçº¿ç¨‹æ± è¿˜åœ¨runningçŠ¶æ€ï¼Œå°†taskåŠ å…¥workQueueé˜»å¡é˜Ÿåˆ—ä¸­ï¼Œå¦‚æœåŠ å…¥æˆåŠŸï¼Œè¿›è¡Œdouble-checkï¼Œå¦‚æœåŠ å…¥å¤±è´¥ï¼ˆå¯èƒ½æ˜¯é˜Ÿåˆ—å·²æ»¡ï¼‰ï¼Œåˆ™æ‰§è¡Œåç»­æ­¥éª¤ï¼›
    double-checkä¸»è¦ç›®çš„æ˜¯åˆ¤æ–­åˆšåŠ å…¥workQueueé˜»å¡é˜Ÿåˆ—çš„taskæ˜¯å¦èƒ½è¢«æ‰§è¡Œ
    Aã€å¦‚æœçº¿ç¨‹æ± å·²ç»ä¸æ˜¯runningçŠ¶æ€äº†ï¼Œåº”è¯¥æ‹’ç»æ·»åŠ æ–°ä»»åŠ¡ï¼Œä»workQueueä¸­åˆ é™¤ä»»åŠ¡
    Bã€å¦‚æœçº¿ç¨‹æ± æ˜¯è¿è¡ŒçŠ¶æ€ï¼Œæˆ–è€…ä»workQueueä¸­åˆ é™¤ä»»åŠ¡å¤±è´¥ï¼ˆåˆšå¥½æœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œå¹¶æ¶ˆè€—äº†è¿™ä¸ªä»»åŠ¡ï¼‰ï¼Œç¡®ä¿è¿˜æœ‰çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼ˆåªè¦æœ‰ä¸€ä¸ªå°±å¤Ÿäº†ï¼‰
3. å¦‚æœçº¿ç¨‹æ± ä¸æ˜¯runningçŠ¶æ€ æˆ–è€… æ— æ³•å…¥é˜Ÿåˆ—ï¼Œå°è¯•å¼€å¯æ–°çº¿ç¨‹ï¼Œæ‰©å®¹è‡³maxPoolSizeï¼Œå¦‚æœaddWork(command, false)å¤±è´¥äº†ï¼Œæ‹’ç»å½“å‰command

ç›´æ¥ä¸Šä¸ªå›¾ï¼ï¼ï¼

ä»ä»£ç åˆ†æï¼ŒaddWorkeræ–¹æ³•æ˜¯å¾ˆé‡è¦çš„ï¼Œå¤šå¤„è¢«ä½¿ç”¨ï¼ŒæŸ¥çœ‹æ­¤æ–¹æ³•æœ‰
```java
/**
 * æ­¤æ–¹æ³•å¯ä»¥æœ‰å››ç§å½¢æ€
 * 1. addWorker(command, true)
 * 2. addWorker(command, false)
 * 3. addWorker(null, false)
 * 4. addWorker(null, true)
 *   ç¬¬ä¸€ä¸ªï¼šçº¿ç¨‹æ•°å°äºcorePoolSizeæ—¶ï¼Œæ”¾ä¸€ä¸ªéœ€è¦å¤„ç†çš„taskè¿›Workers Setã€‚å¦‚æœWorkers Seté•¿åº¦è¶…è¿‡corePoolSizeï¼Œå°±è¿”å›false
 *   ç¬¬äºŒä¸ªï¼šå½“é˜Ÿåˆ—è¢«æ”¾æ»¡æ—¶ï¼Œå°±å°è¯•å°†è¿™ä¸ªæ–°æ¥çš„taskç›´æ¥æ”¾å…¥Workers Setï¼Œè€Œæ­¤æ—¶Workers Setçš„é•¿åº¦é™åˆ¶æ˜¯maximumPoolSizeã€‚å¦‚æœçº¿ç¨‹æ± ä¹Ÿæ»¡äº†çš„è¯å°±è¿”å›false
 *   ç¬¬ä¸‰ä¸ªï¼šæ”¾å…¥ä¸€ä¸ªç©ºçš„taskè¿›workers Setï¼Œé•¿åº¦é™åˆ¶æ˜¯maximumPoolSizeã€‚è¿™æ ·ä¸€ä¸ªtaskä¸ºç©ºçš„workeråœ¨çº¿ç¨‹æ‰§è¡Œçš„æ—¶å€™ä¼šå»ä»»åŠ¡é˜Ÿåˆ—é‡Œæ‹¿ä»»åŠ¡ï¼Œè¿™æ ·å°±ç›¸å½“äºåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹ï¼Œåªæ˜¯æ²¡æœ‰é©¬ä¸Šåˆ†é…ä»»åŠ¡
 *   ç¬¬å››ä¸ªï¼šè¿™ä¸ªæ–¹æ³•å°±æ˜¯æ”¾ä¸€ä¸ªnullçš„taskè¿›Workers Setï¼Œè€Œä¸”æ˜¯åœ¨å°äºcorePoolSizeæ—¶ï¼Œå¦‚æœæ­¤æ—¶Setä¸­çš„æ•°é‡å·²ç»è¾¾åˆ°corePoolSizeé‚£å°±è¿”å›falseï¼Œä»€ä¹ˆä¹Ÿä¸å¹²ã€‚å®é™…ä½¿ç”¨ä¸­æ˜¯åœ¨prestartAllCoreThreads()æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ç”¨æ¥ä¸ºçº¿ç¨‹æ± é¢„å…ˆå¯åŠ¨corePoolSizeä¸ªworkerç­‰å¾…ä»workQueueä¸­è·å–ä»»åŠ¡æ‰§è¡Œ
 *
 *
 *
 1ã€åˆ¤æ–­çº¿ç¨‹æ± å½“å‰æ˜¯å¦ä¸ºå¯ä»¥æ·»åŠ workerçº¿ç¨‹çš„çŠ¶æ€ï¼Œå¯ä»¥åˆ™ç»§ç»­ä¸‹ä¸€æ­¥ï¼Œä¸å¯ä»¥return falseï¼š
    Aã€çº¿ç¨‹æ± çŠ¶æ€>shutdownï¼Œå¯èƒ½ä¸ºstopã€tidyingã€terminatedï¼Œä¸èƒ½æ·»åŠ workerçº¿ç¨‹
    Bã€çº¿ç¨‹æ± çŠ¶æ€==shutdownï¼ŒfirstTaskä¸ä¸ºç©ºï¼Œä¸èƒ½æ·»åŠ workerçº¿ç¨‹ï¼Œå› ä¸ºshutdownçŠ¶æ€çš„çº¿ç¨‹æ± ä¸æ¥æ”¶æ–°ä»»åŠ¡
    Cã€çº¿ç¨‹æ± çŠ¶æ€==shutdownï¼ŒfirstTask==nullï¼ŒworkQueueä¸ºç©ºï¼Œä¸èƒ½æ·»åŠ workerçº¿ç¨‹ï¼Œå› ä¸ºfirstTaskä¸ºç©ºæ˜¯ä¸ºäº†æ·»åŠ ä¸€ä¸ªæ²¡æœ‰ä»»åŠ¡çš„çº¿ç¨‹å†ä»workQueueè·å–taskï¼Œè€ŒworkQueueä¸ºç©ºï¼Œè¯´æ˜æ·»åŠ æ— ä»»åŠ¡çº¿ç¨‹å·²ç»æ²¡æœ‰æ„ä¹‰
2ã€çº¿ç¨‹æ± å½“å‰çº¿ç¨‹æ•°é‡æ˜¯å¦è¶…è¿‡ä¸Šé™ï¼ˆcorePoolSize æˆ– maximumPoolSizeï¼‰ï¼Œè¶…è¿‡äº†return falseï¼Œæ²¡è¶…è¿‡åˆ™å¯¹workerCount+1ï¼Œç»§ç»­ä¸‹ä¸€æ­¥
3ã€åœ¨çº¿ç¨‹æ± çš„ReentrantLockä¿è¯ä¸‹ï¼Œå‘Workers Setä¸­æ·»åŠ æ–°åˆ›å»ºçš„workerå®ä¾‹ï¼Œæ·»åŠ å®Œæˆåè§£é”ï¼Œå¹¶å¯åŠ¨workerçº¿ç¨‹ï¼Œå¦‚æœè¿™ä¸€åˆ‡éƒ½æˆåŠŸäº†ï¼Œreturn trueï¼Œå¦‚æœæ·»åŠ workerå…¥Setå¤±è´¥æˆ–å¯åŠ¨å¤±è´¥ï¼Œè°ƒç”¨addWorkerFailed()é€»è¾‘
 *
 *
 *
 *
 */

private boolean addWorker(Runnable firstTask, boolean core) {
        //å¤–å±‚å¾ªç¯ï¼Œè´Ÿè´£åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // çº¿ç¨‹æ± çš„stateè¶Šå°è¶Šæ˜¯è¿è¡ŒçŠ¶æ€ï¼Œrunnbale=-1ï¼Œshutdown=0,stop=1,tidying=2ï¼Œterminated=3
            //1ã€å¦‚æœçº¿ç¨‹æ± stateå·²ç»è‡³å°‘æ˜¯shutdownçŠ¶æ€äº†
            //2ã€å¹¶ä¸”ä»¥ä¸‹3ä¸ªæ¡ä»¶ä»»æ„ä¸€ä¸ªæ˜¯false
            //  rs == SHUTDOWN         ï¼ˆéšå«ï¼šrs>=SHUTDOWNï¼‰falseæƒ…å†µï¼šçº¿ç¨‹æ± çŠ¶æ€å·²ç»è¶…è¿‡shutdownï¼Œå¯èƒ½æ˜¯stopã€tidyingã€terminatedå…¶ä¸­ä¸€ä¸ªï¼Œå³çº¿ç¨‹æ± å·²ç»ç»ˆæ­¢
            //  firstTask == null      ï¼ˆéšå«ï¼šrs==SHUTDOWNï¼‰falseæƒ…å†µï¼š firstTaskä¸ä¸ºç©ºï¼Œrs==SHUTDOWN ä¸” firstTaskä¸ä¸ºç©ºï¼Œreturn falseï¼Œåœºæ™¯æ˜¯åœ¨çº¿ç¨‹æ± å·²ç»shutdownåï¼Œè¿˜è¦æ·»åŠ æ–°çš„ä»»åŠ¡ï¼Œæ‹’ç»
            //  ! workQueue.isEmpty()  ï¼ˆéšå«ï¼šrs==SHUTDOWNï¼ŒfirstTask==nullï¼‰falseæƒ…å†µï¼š workQueueä¸ºç©ºï¼Œå½“firstTaskä¸ºç©ºæ—¶æ˜¯ä¸ºäº†åˆ›å»ºä¸€ä¸ªæ²¡æœ‰ä»»åŠ¡çš„çº¿ç¨‹ï¼Œå†ä»workQueueä¸­è·å–ä»»åŠ¡ï¼Œå¦‚æœworkQueueå·²ç»ä¸ºç©ºï¼Œé‚£ä¹ˆå°±æ²¡æœ‰æ·»åŠ æ–°workerçº¿ç¨‹çš„å¿…è¦äº†
            // return falseï¼Œå³æ— æ³•addWorker()
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            ////å†…å±‚å¾ªç¯ï¼Œè´Ÿè´£workeræ•°é‡+1
            for (;;) {
                int wc = workerCountOf(c);
                //å¦‚æœworkeræ•°é‡>çº¿ç¨‹æ± æœ€å¤§ä¸Šé™CAPACITYï¼ˆå³ä½¿ç”¨intä½29ä½å¯ä»¥å®¹çº³çš„æœ€å¤§å€¼ï¼‰
                //æˆ–è€…( workeræ•°é‡>corePoolSize æˆ–  workeræ•°é‡>maximumPoolSize )ï¼Œå³å·²ç»è¶…è¿‡äº†ç»™å®šçš„è¾¹ç•Œ
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                //è°ƒç”¨unsafe CASæ“ä½œï¼Œä½¿å¾—workeræ•°é‡+1ï¼ŒæˆåŠŸåˆ™è·³å‡ºretryå¾ªç¯
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                //CAS workeræ•°é‡+1å¤±è´¥ï¼Œå†æ¬¡è¯»å–ctl
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CASå¤±è´¥æ—¶å› ä¸ºworkerCountæ”¹å˜äº†ï¼Œç»§ç»­å†…å±‚å¾ªç¯å°è¯•CASå¯¹workeræ•°é‡+1
            }
        }

        /**
     * workeræ•°é‡+1æˆåŠŸçš„åç»­æ“ä½œ
     * æ·»åŠ åˆ°workers Seté›†åˆï¼Œå¹¶å¯åŠ¨workerçº¿ç¨‹
     */
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //1ã€è®¾ç½®workerè¿™ä¸ªAQSé”çš„åŒæ­¥çŠ¶æ€state=-1
            //2ã€å°†firstTaskè®¾ç½®ç»™workerçš„æˆå‘˜å˜é‡firstTask
            //3ã€ä½¿ç”¨workerè‡ªèº«è¿™ä¸ªrunnableï¼Œè°ƒç”¨ThreadFactoryåˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œå¹¶è®¾ç½®ç»™workerçš„æˆå‘˜å˜é‡thread
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    // å½“è·å–åˆ°é”åï¼Œå†æ¬¡æ£€æŸ¥
                    int rs = runStateOf(ctl.get());

                    //å¦‚æœçº¿ç¨‹æ± åœ¨è¿è¡Œrunning<shutdown æˆ–è€… çº¿ç¨‹æ± å·²ç»shutdownï¼Œä¸”firstTask==nullï¼ˆå¯èƒ½æ˜¯workQueueä¸­ä»æœ‰æœªæ‰§è¡Œå®Œæˆçš„ä»»åŠ¡ï¼Œåˆ›å»ºæ²¡æœ‰åˆå§‹ä»»åŠ¡çš„workerçº¿ç¨‹æ‰§è¡Œï¼‰
                    //workeræ•°é‡-1çš„æ“ä½œåœ¨addWorkerFailed()
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable   çº¿ç¨‹å·²ç»å¯åŠ¨ï¼ŒæŠ›éæ³•çº¿ç¨‹çŠ¶æ€å¼‚å¸¸
                            throw new IllegalThreadStateException();
                        //workersæ˜¯ä¸€ä¸ªHashSet<Worker>
                        workers.add(w);
                        //è®¾ç½®æœ€å¤§çš„æ± å¤§å°largestPoolSizeï¼ŒworkerAddedè®¾ç½®ä¸ºtrue
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                //å¦‚æœå¾€HashSetä¸­æ·»åŠ workeræˆåŠŸï¼Œå¯åŠ¨çº¿ç¨‹
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            //å¦‚æœå¯åŠ¨çº¿ç¨‹å¤±è´¥
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

å’ŒaddWorkerç´§å¯†ç›¸å…³çš„æœ‰ä¸€ä¸ªå«Workerçš„å†…éƒ¨ç±»
```java

 * Workerç±»å¤§ä½“ä¸Šç®¡ç†ç€è¿è¡Œçº¿ç¨‹çš„ä¸­æ–­çŠ¶æ€ å’Œ ä¸€äº›æŒ‡æ ‡
 * Workerç±»æŠ•æœºå–å·§çš„ç»§æ‰¿äº†AbstractQueuedSynchronizeræ¥ç®€åŒ–åœ¨æ‰§è¡Œä»»åŠ¡æ—¶çš„è·å–ã€é‡Šæ”¾é”
 * è¿™æ ·é˜²æ­¢äº†ä¸­æ–­åœ¨è¿è¡Œä¸­çš„ä»»åŠ¡ï¼Œåªä¼šå”¤é†’(ä¸­æ–­)åœ¨ç­‰å¾…ä»workQueueä¸­è·å–ä»»åŠ¡çš„çº¿ç¨‹
 * è§£é‡Šï¼š
 *   ä¸ºä»€ä¹ˆä¸ç›´æ¥æ‰§è¡Œexecute(command)æäº¤çš„commandï¼Œè€Œè¦åœ¨å¤–é¢åŒ…ä¸€å±‚Workerå‘¢ï¼Ÿï¼Ÿ
 *   ä¸»è¦æ˜¯ä¸ºäº†æ§åˆ¶ä¸­æ–­
 *   ç”¨ä»€ä¹ˆæ§åˆ¶ï¼Ÿï¼Ÿ
 *   ç”¨AQSé”ï¼Œå½“è¿è¡Œæ—¶ä¸Šé”ï¼Œå°±ä¸èƒ½ä¸­æ–­ï¼ŒTreadPoolExecutorçš„shutdown()æ–¹æ³•ä¸­æ–­å‰éƒ½è¦è·å–workeré”
 *   åªæœ‰åœ¨ç­‰å¾…ä»workQueueä¸­è·å–ä»»åŠ¡getTask()æ—¶æ‰èƒ½ä¸­æ–­
 * workerå®ç°äº†ä¸€ä¸ªç®€å•çš„ä¸å¯é‡å…¥çš„äº’æ–¥é”ï¼Œè€Œä¸æ˜¯ç”¨ReentrantLockå¯é‡å…¥é”
 * å› ä¸ºæˆ‘ä»¬ä¸æƒ³è®©åœ¨è°ƒç”¨æ¯”å¦‚setCorePoolSize()è¿™ç§çº¿ç¨‹æ± æ§åˆ¶æ–¹æ³•æ—¶å¯ä»¥å†æ¬¡è·å–é”(é‡å…¥)
 * è§£é‡Šï¼š
 *   setCorePoolSize()æ—¶å¯èƒ½ä¼šinterruptIdleWorkers()ï¼Œåœ¨å¯¹ä¸€ä¸ªçº¿ç¨‹interruptæ—¶ä¼šè¦w.tryLock()
 *   å¦‚æœå¯é‡å…¥ï¼Œå°±å¯èƒ½ä¼šåœ¨å¯¹çº¿ç¨‹æ± æ“ä½œçš„æ–¹æ³•ä¸­ä¸­æ–­çº¿ç¨‹ï¼Œç±»ä¼¼æ–¹æ³•è¿˜æœ‰ï¼š
 *   setMaximumPoolSize()
 *   setKeppAliveTime()
 *   allowCoreThreadTimeOut()
 *   shutdown()
 * æ­¤å¤–ï¼Œä¸ºäº†è®©çº¿ç¨‹çœŸæ­£å¼€å§‹åæ‰å¯ä»¥ä¸­æ–­ï¼Œåˆå§‹åŒ–lockçŠ¶æ€ä¸ºè´Ÿå€¼(-1)ï¼Œåœ¨å¼€å§‹runWorker()æ—¶å°†stateç½®ä¸º0ï¼Œè€Œstate>=0æ‰å¯ä»¥ä¸­æ–­
 * 
 * 
 * Workerç»§æ‰¿äº†AQSï¼Œå®ç°äº†Runnableï¼Œè¯´æ˜å…¶æ—¢æ˜¯ä¸€ä¸ªå¯è¿è¡Œçš„ä»»åŠ¡ï¼Œä¹Ÿæ˜¯ä¸€æŠŠé”ï¼ˆä¸å¯é‡å…¥ï¼‰
private final class Worker extends AbstractQueuedSynchronizer implements Runnable
    {
        /**
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         */
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;  //åˆ©ç”¨ThreadFactoryå’Œ Workerè¿™ä¸ªRunnableåˆ›å»ºçš„çº¿ç¨‹å¯¹è±¡
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            //è®¾ç½®AQSçš„åŒæ­¥çŠ¶æ€private volatile int stateï¼Œæ˜¯ä¸€ä¸ªè®¡æ•°å™¨ï¼Œå¤§äº0ä»£è¡¨é”å·²ç»è¢«è·å–
            // åœ¨è°ƒç”¨runWorker()å‰ï¼Œç¦æ­¢interruptä¸­æ–­ï¼Œåœ¨interruptIfStarted()æ–¹æ³•ä¸­ä¼šåˆ¤æ–­ getState()>=0
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            //æ ¹æ®å½“å‰workeråˆ›å»ºä¸€ä¸ªçº¿ç¨‹å¯¹è±¡
            //å½“å‰workeræœ¬èº«å°±æ˜¯ä¸€ä¸ªrunnableä»»åŠ¡,ä¹Ÿå°±æ˜¯ä¸ä¼šç”¨å‚æ•°çš„firstTaskåˆ›å»ºçº¿ç¨‹ï¼Œè€Œæ˜¯è°ƒç”¨å½“å‰worker.run()æ—¶è°ƒç”¨firstTask.run()
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        public void run() {
            //runWorker()æ˜¯ThreadPoolExecutorçš„æ–¹æ³•
            runWorker(this);
        }

        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        
        /**
     * å°è¯•è·å–é”
     * é‡å†™AQSçš„tryAcquire()ï¼ŒAQSæœ¬æ¥å°±æ˜¯è®©å­ç±»æ¥å®ç°çš„
     */
        protected boolean tryAcquire(int unused) {
            //å°è¯•ä¸€æ¬¡å°†stateä»0è®¾ç½®ä¸º1ï¼Œå³â€œé”å®šâ€çŠ¶æ€ï¼Œä½†ç”±äºæ¯æ¬¡éƒ½æ˜¯state 0->1ï¼Œè€Œä¸æ˜¯+1ï¼Œé‚£ä¹ˆè¯´æ˜ä¸å¯é‡å…¥
            //ä¸”state==-1æ—¶ä¹Ÿä¸ä¼šè·å–åˆ°é”
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        /**
     * å°è¯•é‡Šæ”¾é”
     * ä¸æ˜¯state-1ï¼Œè€Œæ˜¯ç½®ä¸º0
     */
        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock()        { acquire(1); }
        public boolean tryLock()  { return tryAcquire(1); }
        public void unlock()      { release(1); }
        public boolean isLocked() { return isHeldExclusively(); }

        /**
     * ä¸­æ–­ï¼ˆå¦‚æœè¿è¡Œï¼‰
     * shutdownNowæ—¶ä¼šå¾ªç¯å¯¹workerçº¿ç¨‹æ‰§è¡Œ
     * ä¸”ä¸éœ€è¦è·å–workeré”ï¼Œå³ä½¿åœ¨workerè¿è¡Œæ—¶ä¹Ÿå¯ä»¥ä¸­æ–­
     */
        void interruptIfStarted() {
            Thread t;
            //å¦‚æœstate>=0ã€t!=nullã€ä¸”tæ²¡æœ‰è¢«ä¸­æ–­
            //new Worker()æ—¶state==-1ï¼Œè¯´æ˜ä¸èƒ½ä¸­æ–­
            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }
```
Workerç±»
Workerç±»æœ¬èº«æ—¢å®ç°äº†Runnableï¼Œåˆç»§æ‰¿äº†AbstractQueuedSynchronizerï¼ˆä»¥ä¸‹ç®€ç§°AQSï¼‰ï¼Œæ‰€ä»¥å…¶æ—¢æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œçš„ä»»åŠ¡ï¼Œåˆå¯ä»¥è¾¾åˆ°é”çš„æ•ˆæœ
new Worker()
1ã€å°†AQSçš„stateç½®ä¸º-1ï¼Œåœ¨runWoker()å‰ä¸å…è®¸ä¸­æ–­
2ã€å¾…æ‰§è¡Œçš„ä»»åŠ¡ä¼šä»¥å‚æ•°ä¼ å…¥ï¼Œå¹¶èµ‹äºˆfirstTask
3ã€ç”¨Workerè¿™ä¸ªRunnableåˆ›å»ºThread

ä¹‹æ‰€ä»¥Workerè‡ªå·±å®ç°Runnableï¼Œå¹¶åˆ›å»ºThreadï¼Œåœ¨firstTaskå¤–åŒ…ä¸€å±‚ï¼Œæ˜¯å› ä¸ºè¦é€šè¿‡Workeræ§åˆ¶ä¸­æ–­ï¼Œè€ŒfirstTaskè¿™ä¸ªå·¥ä½œä»»åŠ¡åªæ˜¯è´Ÿè´£æ‰§è¡Œä¸šåŠ¡
Workeræ§åˆ¶ä¸­æ–­ä¸»è¦æœ‰ä»¥ä¸‹å‡ æ–¹é¢ï¼š
1ã€åˆå§‹AQSçŠ¶æ€ä¸º-1ï¼Œæ­¤æ—¶ä¸å…è®¸ä¸­æ–­interrupt()ï¼Œåªæœ‰åœ¨workerçº¿ç¨‹å¯åŠ¨äº†ï¼Œæ‰§è¡Œäº†runWoker()ï¼Œå°†stateç½®ä¸º0ï¼Œæ‰èƒ½ä¸­æ–­
    ä¸å…è®¸ä¸­æ–­ä½“ç°åœ¨ï¼š
    Aã€shutdown()çº¿ç¨‹æ± æ—¶ï¼Œä¼šå¯¹æ¯ä¸ªworker tryLock()ä¸Šé”ï¼Œè€ŒWorkerç±»è¿™ä¸ªAQSçš„tryAcquire()æ–¹æ³•æ˜¯å›ºå®šå°†stateä»0->1ï¼Œæ•…åˆå§‹çŠ¶æ€state==-1æ—¶tryLock()å¤±è´¥ï¼Œæ²¡å‘interrupt()
    Bã€shutdownNow()çº¿ç¨‹æ± æ—¶ï¼Œä¸ç”¨tryLock()ä¸Šé”ï¼Œä½†è°ƒç”¨worker.interruptIfStarted()ç»ˆæ­¢workerï¼ŒinterruptIfStarted()ä¹Ÿæœ‰state>0æ‰èƒ½interruptçš„é€»è¾‘
2ã€ä¸ºäº†é˜²æ­¢æŸç§æƒ…å†µä¸‹ï¼Œåœ¨è¿è¡Œä¸­çš„workerè¢«ä¸­æ–­ï¼ŒrunWorker()æ¯æ¬¡è¿è¡Œä»»åŠ¡æ—¶éƒ½ä¼šlock()ä¸Šé”ï¼Œè€Œshutdown()è¿™ç±»å¯èƒ½ä¼šç»ˆæ­¢workerçš„æ“ä½œéœ€è¦å…ˆè·å–workerçš„é”ï¼Œè¿™æ ·å°±é˜²æ­¢äº†ä¸­æ–­æ­£åœ¨è¿è¡Œçš„çº¿ç¨‹

Workerå®ç°çš„AQSä¸ºä¸å¯é‡å…¥é”ï¼Œä¸ºäº†æ˜¯åœ¨è·å¾—workeré”çš„æƒ…å†µä¸‹å†è¿›å…¥å…¶å®ƒä¸€äº›éœ€è¦åŠ é”çš„æ–¹æ³•

Workerå’ŒTaskçš„åŒºåˆ«ï¼š
Workeræ˜¯çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ï¼Œè€ŒTaskè™½ç„¶æ˜¯runnableï¼Œä½†æ˜¯å¹¶æ²¡æœ‰çœŸæ­£æ‰§è¡Œï¼Œåªæ˜¯è¢«Workerè°ƒç”¨äº†runæ–¹æ³•ï¼Œåé¢ä¼šçœ‹åˆ°è¿™éƒ¨åˆ†çš„å®ç°ã€‚

```java

/**
 * Main worker run loop.  Repeatedly gets tasks from queue and
 * executes them, while coping with a number of issues:
 * é‡å¤çš„ä»é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡å¹¶æ‰§è¡Œï¼ŒåŒæ—¶åº”å¯¹ä¸€äº›é—®é¢˜ï¼š
 *
 * 1. We may start out with an initial task, in which case we
 * don't need to get the first one. Otherwise, as long as pool is
 * running, we get tasks from getTask. If it returns null then the
 * worker exits due to changed pool state or configuration
 * parameters.  Other exits result from exception throws in
 * external code, in which case completedAbruptly holds, which
 * usually leads processWorkerExit to replace this thread.
 * æˆ‘ä»¬å¯èƒ½ä½¿ç”¨ä¸€ä¸ªåˆå§‹åŒ–ä»»åŠ¡å¼€å§‹ï¼Œå³firstTaskä¸ºnull
 * ç„¶ååªè¦çº¿ç¨‹æ± åœ¨è¿è¡Œï¼Œæˆ‘ä»¬å°±ä»getTask()è·å–ä»»åŠ¡
 * å¦‚æœgetTask()è¿”å›nullï¼Œåˆ™workerç”±äºæ”¹å˜äº†çº¿ç¨‹æ± çŠ¶æ€æˆ–å‚æ•°é…ç½®è€Œé€€å‡º
 * å…¶å®ƒé€€å‡ºå› ä¸ºå¤–éƒ¨ä»£ç æŠ›å¼‚å¸¸äº†ï¼Œè¿™ä¼šä½¿å¾—completedAbruptlyä¸ºtrueï¼Œè¿™ä¼šå¯¼è‡´åœ¨processWorkerExit()æ–¹æ³•ä¸­æ›¿æ¢å½“å‰çº¿ç¨‹
 *
 * 2. Before running any task, the lock is acquired to prevent
 * other pool interrupts while the task is executing, and
 * clearInterruptsForTaskRun called to ensure that unless pool is
 * stopping, this thread does not have its interrupt set.
 * åœ¨ä»»ä½•ä»»åŠ¡æ‰§è¡Œä¹‹å‰ï¼Œéƒ½éœ€è¦å¯¹workeråŠ é”å»é˜²æ­¢åœ¨ä»»åŠ¡è¿è¡Œæ—¶ï¼Œå…¶å®ƒçš„çº¿ç¨‹æ± ä¸­æ–­æ“ä½œ
 * clearInterruptsForTaskRunä¿è¯é™¤éçº¿ç¨‹æ± æ­£åœ¨stopingï¼Œçº¿ç¨‹ä¸ä¼šè¢«è®¾ç½®ä¸­æ–­æ ‡ç¤º
 *
 * 3. Each task run is preceded by a call to beforeExecute, which
 * might throw an exception, in which case we cause thread to die
 * (breaking loop with completedAbruptly true) without processing
 * the task.
 * æ¯ä¸ªä»»åŠ¡æ‰§è¡Œå‰ä¼šè°ƒç”¨beforeExecute()ï¼Œå…¶ä¸­å¯èƒ½æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼Œè¿™ç§æƒ…å†µä¸‹ä¼šå¯¼è‡´çº¿ç¨‹dieï¼ˆè·³å‡ºå¾ªç¯ï¼Œä¸”completedAbruptly==trueï¼‰ï¼Œæ²¡æœ‰æ‰§è¡Œä»»åŠ¡
 * å› ä¸ºbeforeExecute()çš„å¼‚å¸¸æ²¡æœ‰cacheä½ï¼Œä¼šä¸ŠæŠ›ï¼Œè·³å‡ºå¾ªç¯
 *
 * 4. Assuming beforeExecute completes normally, we run the task,
 * gathering any of its thrown exceptions to send to
 * afterExecute. We separately handle RuntimeException, Error
 * (both of which the specs guarantee that we trap) and arbitrary
 * Throwables.  Because we cannot rethrow Throwables within
 * Runnable.run, we wrap them within Errors on the way out (to the
 * thread's UncaughtExceptionHandler).  Any thrown exception also
 * conservatively causes thread to die.
 * å‡å®šbeforeExecute()æ­£å¸¸å®Œæˆï¼Œæˆ‘ä»¬æ‰§è¡Œä»»åŠ¡
 * æ±‡æ€»ä»»ä½•æŠ›å‡ºçš„å¼‚å¸¸å¹¶å‘é€ç»™afterExecute(task, thrown)
 * å› ä¸ºæˆ‘ä»¬ä¸èƒ½åœ¨Runnable.run()æ–¹æ³•ä¸­é‡æ–°ä¸ŠæŠ›Throwablesï¼Œæˆ‘ä»¬å°†ThrowablesåŒ…è£…åˆ°Errorsä¸ŠæŠ›ï¼ˆä¼šåˆ°çº¿ç¨‹çš„UncaughtExceptionHandlerå»å¤„ç†ï¼‰
 * ä»»ä½•ä¸ŠæŠ›çš„å¼‚å¸¸éƒ½ä¼šå¯¼è‡´çº¿ç¨‹die
 *
 * 5. After task.run completes, we call afterExecute, which may
 * also throw an exception, which will also cause thread to
 * die. According to JLS Sec 14.20, this exception is the one that
 * will be in effect even if task.run throws.
 * ä»»åŠ¡æ‰§è¡Œç»“æŸåï¼Œè°ƒç”¨afterExecute()ï¼Œä¹Ÿå¯èƒ½æŠ›å¼‚å¸¸ï¼Œä¹Ÿä¼šå¯¼è‡´çº¿ç¨‹die
 * æ ¹æ®JLS Sec 14.20ï¼Œè¿™ä¸ªå¼‚å¸¸ï¼ˆfinallyä¸­çš„å¼‚å¸¸ï¼‰ä¼šç”Ÿæ•ˆ
 *
 * The net effect of the exception mechanics is that afterExecute
 * and the thread's UncaughtExceptionHandler have as accurate
 * information as we can provide about any problems encountered by
 * user code.
 *
 * @param w the worker
 */final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
                // new Worker()æ˜¯state==-1ï¼Œæ­¤å¤„æ˜¯è°ƒç”¨Workerç±»çš„tryRelease()æ–¹æ³•ï¼Œå°†stateç½®ä¸º0ï¼Œ è€ŒinterruptIfStarted()ä¸­åªæœ‰state>=0æ‰å…è®¸è°ƒç”¨ä¸­æ–­
    boolean completedAbruptly = true; //æ˜¯å¦â€œçªç„¶å®Œæˆâ€ï¼Œå¦‚æœæ˜¯ç”±äºå¼‚å¸¸å¯¼è‡´çš„è¿›å…¥finallyï¼Œé‚£ä¹ˆcompletedAbruptly==trueå°±æ˜¯çªç„¶å®Œæˆçš„
    try {
        /**
         * å¦‚æœtaskä¸ä¸ºnullï¼Œæˆ–è€…ä»é˜»å¡é˜Ÿåˆ—ä¸­getTask()ä¸ä¸ºnull
         */
        while (task != null || (task = getTask()) != null) {
            w.lock(); //ä¸Šé”ï¼Œä¸æ˜¯ä¸ºäº†é˜²æ­¢å¹¶å‘æ‰§è¡Œä»»åŠ¡ï¼Œä¸ºäº†åœ¨shutdown()æ—¶ä¸ç»ˆæ­¢æ­£åœ¨è¿è¡Œçš„worker
             
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            /**
             * clearInterruptsForTaskRunæ“ä½œ
             * ç¡®ä¿åªæœ‰åœ¨çº¿ç¨‹stopingæ—¶ï¼Œæ‰ä¼šè¢«è®¾ç½®ä¸­æ–­æ ‡ç¤ºï¼Œå¦åˆ™æ¸…é™¤ä¸­æ–­æ ‡ç¤º
             * 1ã€å¦‚æœçº¿ç¨‹æ± çŠ¶æ€>=stopï¼Œä¸”å½“å‰çº¿ç¨‹æ²¡æœ‰è®¾ç½®ä¸­æ–­çŠ¶æ€ï¼Œwt.interrupt()
             * 2ã€å¦‚æœä¸€å¼€å§‹åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€<stopï¼Œä½†Thread.interrupted()ä¸ºtrueï¼Œå³çº¿ç¨‹å·²ç»è¢«ä¸­æ–­ï¼Œåˆæ¸…é™¤äº†ä¸­æ–­æ ‡ç¤ºï¼Œå†æ¬¡åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦>=stop
             *   æ˜¯ï¼Œå†æ¬¡è®¾ç½®ä¸­æ–­æ ‡ç¤ºï¼Œwt.interrupt()
             *   å¦ï¼Œä¸åšæ“ä½œï¼Œæ¸…é™¤ä¸­æ–­æ ‡ç¤ºåè¿›è¡Œåç»­æ­¥éª¤
             */
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt(); //å½“å‰çº¿ç¨‹è°ƒç”¨interrupt()ä¸­æ–­
             
            try {
                //æ‰§è¡Œå‰ï¼ˆå­ç±»å®ç°ï¼‰
                beforeExecute(wt, task);
                 
                Throwable thrown = null;
                try {
                    task.run();
                } 
                catch (RuntimeException x) {
                    thrown = x; throw x;
                } 
                catch (Error x) {
                    thrown = x; throw x;
                } 
                catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } 
                finally {
                    //æ‰§è¡Œåï¼ˆå­ç±»å®ç°ï¼‰
                    afterExecute(task, thrown); //è¿™é‡Œå°±è€ƒéªŒcatchå’Œfinallyçš„æ‰§è¡Œé¡ºåºäº†ï¼Œå› ä¸ºè¦ä»¥thrownä¸ºå‚æ•°
                }
            } 
            finally {
                task = null; //taskç½®ä¸ºnull
                w.completedTasks++; //å®Œæˆä»»åŠ¡æ•°+1
                w.unlock(); //è§£é”
            }
        }
         
        completedAbruptly = false;
    } 
    finally {
        //å¤„ç†workerçš„é€€å‡º
        processWorkerExit(w, completedAbruptly);
    }
}
```
æ‰§è¡Œæµç¨‹ï¼š
1ã€Workerçº¿ç¨‹å¯åŠ¨åï¼Œé€šè¿‡Workerç±»çš„run()æ–¹æ³•è°ƒç”¨runWorker(this)
2ã€æ‰§è¡Œä»»åŠ¡ä¹‹å‰ï¼Œé¦–å…ˆworker.unlock()ï¼Œå°†AQSçš„stateç½®ä¸º0ï¼Œå…è®¸ä¸­æ–­å½“å‰workerçº¿ç¨‹
3ã€å¼€å§‹æ‰§è¡ŒfirstTaskï¼Œè°ƒç”¨task.run()ï¼Œåœ¨æ‰§è¡Œä»»åŠ¡å‰ä¼šä¸Šé”wroker.lock()ï¼Œåœ¨æ‰§è¡Œå®Œä»»åŠ¡åä¼šè§£é”ï¼Œä¸ºäº†é˜²æ­¢åœ¨ä»»åŠ¡è¿è¡Œæ—¶è¢«çº¿ç¨‹æ± ä¸€äº›ä¸­æ–­æ“ä½œä¸­æ–­
4ã€åœ¨ä»»åŠ¡æ‰§è¡Œå‰åï¼Œå¯ä»¥æ ¹æ®ä¸šåŠ¡åœºæ™¯è‡ªå®šä¹‰beforeExecute() å’Œ afterExecute()æ–¹æ³•
5ã€æ— è®ºåœ¨beforeExecute()ã€task.run()ã€afterExecute()å‘ç”Ÿå¼‚å¸¸ä¸ŠæŠ›ï¼Œéƒ½ä¼šå¯¼è‡´workerçº¿ç¨‹ç»ˆæ­¢ï¼Œè¿›å…¥processWorkerExit()å¤„ç†workeré€€å‡ºçš„æµç¨‹
6ã€å¦‚æ­£å¸¸æ‰§è¡Œå®Œå½“å‰taskåï¼Œä¼šé€šè¿‡getTask()ä»é˜»å¡é˜Ÿåˆ—ä¸­è·å–æ–°ä»»åŠ¡ï¼Œå½“é˜Ÿåˆ—ä¸­æ²¡æœ‰ä»»åŠ¡ï¼Œä¸”è·å–ä»»åŠ¡è¶…æ—¶ï¼Œé‚£ä¹ˆå½“å‰workerä¹Ÿä¼šè¿›å…¥é€€å‡ºæµç¨‹

5ã€getTask()  --  è·å–ä»»åŠ¡

```java
/**
 * Performs blocking or timed wait for a task, depending on
 * current configuration settings, or returns null if this worker
 * must exit because of any of:  ä»¥ä¸‹æƒ…å†µä¼šè¿”å›null
 * 1. There are more than maximumPoolSize workers (due to
 *    a call to setMaximumPoolSize).
 *    è¶…è¿‡äº†maximumPoolSizeè®¾ç½®çš„çº¿ç¨‹æ•°é‡ï¼ˆå› ä¸ºè°ƒç”¨äº†setMaximumPoolSize()ï¼‰
 * 2. The pool is stopped.
 *    çº¿ç¨‹æ± è¢«stop
 * 3. The pool is shutdown and the queue is empty.
 *    çº¿ç¨‹æ± è¢«shutdownï¼Œå¹¶ä¸”workQueueç©ºäº†
 * 4. This worker timed out waiting for a task, and timed-out
 *    workers are subject to termination (that is,
 *    {@code allowCoreThreadTimeOut || workerCount > corePoolSize})
 *    both before and after the timed wait.
 *    çº¿ç¨‹ç­‰å¾…ä»»åŠ¡è¶…æ—¶
 *
 * @return task, or null if the worker must exit, in which case
 *         workerCount is decremented
 *         è¿”å›nullè¡¨ç¤ºè¿™ä¸ªworkerè¦ç»“æŸäº†ï¼Œè¿™ç§æƒ…å†µä¸‹workerCount-1
 */
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?
 
    /**
     * å¤–å±‚å¾ªç¯
     * ç”¨äºåˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€
     */
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
 
        // Check if queue empty only if necessary.
        /**
         * å¯¹çº¿ç¨‹æ± çŠ¶æ€çš„åˆ¤æ–­ï¼Œä¸¤ç§æƒ…å†µä¼šworkerCount-1ï¼Œå¹¶ä¸”è¿”å›null
         * çº¿ç¨‹æ± çŠ¶æ€ä¸ºshutdownï¼Œä¸”workQueueä¸ºç©ºï¼ˆåæ˜ äº†shutdownçŠ¶æ€çš„çº¿ç¨‹æ± è¿˜æ˜¯è¦æ‰§è¡ŒworkQueueä¸­å‰©ä½™çš„ä»»åŠ¡çš„ï¼‰
         * çº¿ç¨‹æ± çŠ¶æ€ä¸ºstopï¼ˆshutdownNow()ä¼šå¯¼è‡´å˜æˆSTOPï¼‰ï¼ˆæ­¤æ—¶ä¸ç”¨è€ƒè™‘workQueueçš„æƒ…å†µï¼‰
         */
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount(); //å¾ªç¯çš„CASå‡å°‘workeræ•°é‡ï¼Œç›´åˆ°æˆåŠŸ
            return null;
        }
 
        boolean timed;      // Are workers subject to culling?
                            // æ˜¯å¦éœ€è¦å®šæ—¶ä»workQueueä¸­è·å–
         
        /**
         * å†…å±‚å¾ªç¯
         * è¦ä¹ˆbreakå»workQueueè·å–ä»»åŠ¡
         * è¦ä¹ˆè¶…æ—¶äº†ï¼Œworker count-1
         */
        for (;;) {
            int wc = workerCountOf(c);
            timed = allowCoreThreadTimeOut || wc > corePoolSize; //allowCoreThreadTimeOuté»˜è®¤ä¸ºfalse
                                                                 //å¦‚æœallowCoreThreadTimeOutä¸ºtrueï¼Œè¯´æ˜corePoolSizeå’Œmaximuméƒ½éœ€è¦å®šæ—¶
             
            //å¦‚æœå½“å‰æ‰§è¡Œçº¿ç¨‹æ•°<maximumPoolSizeï¼Œå¹¶ä¸”timedOut å’Œ timed ä»»ä¸€ä¸ºfalseï¼Œè·³å‡ºå¾ªç¯ï¼Œå¼€å§‹ä»workQueueè·å–ä»»åŠ¡
            if (wc <= maximumPoolSize && ! (timedOut && timed))
                break;
             
            /**
             * å¦‚æœåˆ°äº†è¿™ä¸€æ­¥ï¼Œè¯´æ˜è¦ä¹ˆçº¿ç¨‹æ•°é‡è¶…è¿‡äº†maximumPoolSizeï¼ˆå¯èƒ½maximumPoolSizeè¢«ä¿®æ”¹äº†ï¼‰
             * è¦ä¹ˆæ—¢éœ€è¦è®¡æ—¶timed==trueï¼Œä¹Ÿè¶…æ—¶äº†timedOut==true
             * workeræ•°é‡-1ï¼Œå‡ä¸€æ‰§è¡Œä¸€æ¬¡å°±è¡Œäº†ï¼Œç„¶åè¿”å›nullï¼Œåœ¨runWorker()ä¸­ä¼šæœ‰é€»è¾‘å‡å°‘workerçº¿ç¨‹
             * å¦‚æœæœ¬æ¬¡å‡ä¸€å¤±è´¥ï¼Œç»§ç»­å†…å±‚å¾ªç¯å†æ¬¡å°è¯•å‡ä¸€
             */
            if (compareAndDecrementWorkerCount(c))
                return null;
             
            //å¦‚æœå‡æ•°é‡å¤±è´¥ï¼Œå†æ¬¡è¯»å–ctl
            c = ctl.get();  // Re-read ctl
             
            //å¦‚æœçº¿ç¨‹æ± è¿è¡ŒçŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œç»§ç»­å¤–å±‚å¾ªç¯
            //å¦‚æœçŠ¶æ€æ²¡å˜ï¼Œç»§ç»­å†…å±‚å¾ªç¯
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
 
        try {
            //poll() - ä½¿ç”¨  LockSupport.parkNanos(this, nanosTimeout) æŒ‚èµ·ä¸€æ®µæ—¶é—´ï¼Œinterrupt()æ—¶ä¸ä¼šæŠ›å¼‚å¸¸ï¼Œä½†ä¼šæœ‰ä¸­æ–­å“åº”
            //take() - ä½¿ç”¨ LockSupport.park(this) æŒ‚èµ·ï¼Œinterrupt()æ—¶ä¸ä¼šæŠ›å¼‚å¸¸ï¼Œä½†ä¼šæœ‰ä¸­æ–­å“åº”
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :    //å¤§äºcorePoolSize
                workQueue.take();                                        //å°äºç­‰äºcorePoolSize
             
            //å¦‚è·å–åˆ°äº†ä»»åŠ¡å°±è¿”å›
            if (r != null)
                return r;
             
            //æ²¡æœ‰è¿”å›ï¼Œè¯´æ˜è¶…æ—¶ï¼Œé‚£ä¹ˆåœ¨ä¸‹ä¸€æ¬¡å†…å±‚å¾ªç¯æ—¶ä¼šè¿›å…¥worker countå‡ä¸€çš„æ­¥éª¤
            timedOut = true;
        } 
        /**
              * blockingQueueçš„take()é˜»å¡ä½¿ç”¨LockSupport.park(this)è¿›å…¥waitçŠ¶æ€çš„ï¼Œå¯¹LockSupport.park(this)è¿›è¡Œinterruptä¸ä¼šæŠ›å¼‚å¸¸ï¼Œä½†è¿˜æ˜¯ä¼šæœ‰ä¸­æ–­å“åº”
              * ä½†AQSçš„ConditionObjectçš„await()å¯¹ä¸­æ–­çŠ¶æ€åšäº†åˆ¤æ–­ï¼Œä¼šæŠ¥å‘Šä¸­æ–­çŠ¶æ€ reportInterruptAfterWait(interruptMode)
              * å°±ä¼šä¸ŠæŠ›InterruptedExceptionï¼Œåœ¨æ­¤å¤„æ•è·ï¼Œé‡æ–°å¼€å§‹å¾ªç¯
              * å¦‚æœæ˜¯ç”±äºshutdown()ç­‰æ“ä½œå¯¼è‡´çš„ç©ºé—²workerä¸­æ–­å“åº”ï¼Œåœ¨å¤–å±‚å¾ªç¯åˆ¤æ–­çŠ¶æ€æ—¶ï¼Œå¯èƒ½return null
              */
        catch (InterruptedException retry) { 
            timedOut = false; //å“åº”ä¸­æ–­ï¼Œé‡æ–°å¼€å§‹ï¼Œä¸­æ–­çŠ¶æ€ä¼šè¢«æ¸…é™¤
        }
    }
}
```

getTask()
æ‰§è¡Œæµç¨‹ï¼š
1ã€é¦–å…ˆåˆ¤æ–­æ˜¯å¦å¯ä»¥æ»¡è¶³ä»workQueueä¸­è·å–ä»»åŠ¡çš„æ¡ä»¶ï¼Œä¸æ»¡è¶³return null
    Aã€çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦æ»¡è¶³ï¼š
        ï¼ˆaï¼‰shutdownçŠ¶æ€ + workQueueä¸ºç©º æˆ– stopçŠ¶æ€ï¼Œéƒ½ä¸æ»¡è¶³ï¼Œå› ä¸ºè¢«shutdownåè¿˜æ˜¯è¦æ‰§è¡ŒworkQueueå‰©ä½™çš„ä»»åŠ¡ï¼Œä½†workQueueä¹Ÿä¸ºç©ºï¼Œå°±å¯ä»¥é€€å‡ºäº†
        ï¼ˆbï¼‰stopçŠ¶æ€ï¼ŒshutdownNow()æ“ä½œä¼šä½¿çº¿ç¨‹æ± è¿›å…¥stopï¼Œæ­¤æ—¶ä¸æ¥å—æ–°ä»»åŠ¡ï¼Œä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼ŒworkQueueä¸­çš„ä»»åŠ¡ä¹Ÿä¸æ‰§è¡Œäº†ï¼Œæ•…return nullè¿”å›
    Bã€çº¿ç¨‹æ•°é‡æ˜¯å¦è¶…è¿‡maximumPoolSize æˆ– è·å–ä»»åŠ¡æ˜¯å¦è¶…æ—¶
        ï¼ˆaï¼‰çº¿ç¨‹æ•°é‡è¶…è¿‡maximumPoolSizeå¯èƒ½æ˜¯çº¿ç¨‹æ± åœ¨è¿è¡Œæ—¶è¢«è°ƒç”¨äº†setMaximumPoolSize()è¢«æ”¹å˜äº†å¤§å°ï¼Œå¦åˆ™å·²ç»addWorker()æˆåŠŸä¸ä¼šè¶…è¿‡maximumPoolSize
        ï¼ˆbï¼‰å¦‚æœ å½“å‰çº¿ç¨‹æ•°é‡>corePoolSizeï¼Œæ‰ä¼šæ£€æŸ¥æ˜¯å¦è·å–ä»»åŠ¡è¶…æ—¶ï¼Œè¿™ä¹Ÿä½“ç°äº†å½“çº¿ç¨‹æ•°é‡è¾¾åˆ°maximumPoolSizeåï¼Œå¦‚æœä¸€ç›´æ²¡æœ‰æ–°ä»»åŠ¡ï¼Œä¼šé€æ¸ç»ˆæ­¢workerçº¿ç¨‹ç›´åˆ°corePoolSize
2ã€å¦‚æœæ»¡è¶³è·å–ä»»åŠ¡æ¡ä»¶ï¼Œæ ¹æ®æ˜¯å¦éœ€è¦å®šæ—¶è·å–è°ƒç”¨ä¸åŒæ–¹æ³•ï¼š
    Aã€workQueue.poll()ï¼šå¦‚æœåœ¨keepAliveTimeæ—¶é—´å†…ï¼Œé˜»å¡é˜Ÿåˆ—è¿˜æ˜¯æ²¡æœ‰ä»»åŠ¡ï¼Œè¿”å›null
    Bã€workQueue.take()ï¼šå¦‚æœé˜»å¡é˜Ÿåˆ—ä¸ºç©ºï¼Œå½“å‰çº¿ç¨‹ä¼šè¢«æŒ‚èµ·ç­‰å¾…ï¼›å½“é˜Ÿåˆ—ä¸­æœ‰ä»»åŠ¡åŠ å…¥æ—¶ï¼Œçº¿ç¨‹è¢«å”¤é†’ï¼Œtakeæ–¹æ³•è¿”å›ä»»åŠ¡
3ã€åœ¨é˜»å¡ä»workQueueä¸­è·å–ä»»åŠ¡æ—¶ï¼Œå¯ä»¥è¢«interrupt()ä¸­æ–­ï¼Œä»£ç ä¸­æ•è·äº†InterruptedExceptionï¼Œé‡ç½®timedOutä¸ºåˆå§‹å€¼falseï¼Œå†æ¬¡æ‰§è¡Œç¬¬1æ­¥ä¸­çš„åˆ¤æ–­ï¼Œæ»¡è¶³å°±ç»§ç»­è·å–ä»»åŠ¡ï¼Œä¸æ»¡è¶³return nullï¼Œä¼šè¿›å…¥workeré€€å‡ºçš„æµç¨‹

6ã€processWorkerExit()  --  workerçº¿ç¨‹é€€å‡º
```java
/**
 * Performs cleanup and bookkeeping for a dying worker. Called
 * only from worker threads. Unless completedAbruptly is set,
 * assumes that workerCount has already been adjusted to account
 * for exit.  This method removes thread from worker set, and
 * possibly terminates the pool or replaces the worker if either
 * it exited due to user task exception or if fewer than
 * corePoolSize workers are running or queue is non-empty but
 * there are no workers.
 *
 * @param w the worker
 * @param completedAbruptly if the worker died due to user exception
 */
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    /**
     * 1ã€workeræ•°é‡-1
     * å¦‚æœæ˜¯çªç„¶ç»ˆæ­¢ï¼Œè¯´æ˜æ˜¯taskæ‰§è¡Œæ—¶å¼‚å¸¸æƒ…å†µå¯¼è‡´ï¼Œå³run()æ–¹æ³•æ‰§è¡Œæ—¶å‘ç”Ÿäº†å¼‚å¸¸ï¼Œé‚£ä¹ˆæ­£åœ¨å·¥ä½œçš„workerçº¿ç¨‹æ•°é‡éœ€è¦-1
     * å¦‚æœä¸æ˜¯çªç„¶ç»ˆæ­¢ï¼Œè¯´æ˜æ˜¯workerçº¿ç¨‹æ²¡æœ‰taskå¯æ‰§è¡Œäº†ï¼Œä¸ç”¨-1ï¼Œå› ä¸ºå·²ç»åœ¨getTask()æ–¹æ³•ä¸­-1äº†
     */
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted ä»£ç å’Œæ³¨é‡Šæ­£å¥½ç›¸åå•Š
        decrementWorkerCount();
 
    /**
     * 2ã€ä»Workers Setä¸­ç§»é™¤worker
     */
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        completedTaskCount += w.completedTasks; //æŠŠworkerçš„å®Œæˆä»»åŠ¡æ•°åŠ åˆ°çº¿ç¨‹æ± çš„å®Œæˆä»»åŠ¡æ•°
        workers.remove(w); //ä»HashSet<Worker>ä¸­ç§»é™¤
    } finally {
        mainLock.unlock();
    }
 
    /**
     * 3ã€åœ¨å¯¹çº¿ç¨‹æ± æœ‰è´Ÿæ•ˆç›Šçš„æ“ä½œæ—¶ï¼Œéƒ½éœ€è¦â€œå°è¯•ç»ˆæ­¢â€çº¿ç¨‹æ± 
     * ä¸»è¦æ˜¯åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦æ»¡è¶³ç»ˆæ­¢çš„çŠ¶æ€
     * å¦‚æœçŠ¶æ€æ»¡è¶³ï¼Œä½†è¿˜æœ‰çº¿ç¨‹æ± è¿˜æœ‰çº¿ç¨‹ï¼Œå°è¯•å¯¹å…¶å‘å‡ºä¸­æ–­å“åº”ï¼Œä½¿å…¶èƒ½è¿›å…¥é€€å‡ºæµç¨‹
     * æ²¡æœ‰çº¿ç¨‹äº†ï¼Œæ›´æ–°çŠ¶æ€ä¸ºtidying->terminated
     */
    tryTerminate();
 
    /**
     * 4ã€æ˜¯å¦éœ€è¦å¢åŠ workerçº¿ç¨‹
     * çº¿ç¨‹æ± çŠ¶æ€æ˜¯running æˆ– shutdown
     * å¦‚æœå½“å‰çº¿ç¨‹æ˜¯çªç„¶ç»ˆæ­¢çš„ï¼ŒaddWorker()
     * å¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯çªç„¶ç»ˆæ­¢çš„ï¼Œä½†å½“å‰çº¿ç¨‹æ•°é‡ < è¦ç»´æŠ¤çš„çº¿ç¨‹æ•°é‡ï¼ŒaddWorker()
     * æ•…å¦‚æœè°ƒç”¨çº¿ç¨‹æ± shutdown()ï¼Œç›´åˆ°workQueueä¸ºç©ºå‰ï¼Œçº¿ç¨‹æ± éƒ½ä¼šç»´æŒcorePoolSizeä¸ªçº¿ç¨‹ï¼Œç„¶åå†é€æ¸é”€æ¯è¿™corePoolSizeä¸ªçº¿ç¨‹
     */
    int c = ctl.get();
    //å¦‚æœçŠ¶æ€æ˜¯runningã€shutdownï¼Œå³tryTerminate()æ²¡æœ‰æˆåŠŸç»ˆæ­¢çº¿ç¨‹æ± ï¼Œå°è¯•å†æ·»åŠ ä¸€ä¸ªworker
    if (runStateLessThan(c, STOP)) {
        //ä¸æ˜¯çªç„¶å®Œæˆçš„ï¼Œå³æ²¡æœ‰taskä»»åŠ¡å¯ä»¥è·å–è€Œå®Œæˆçš„ï¼Œè®¡ç®—minï¼Œå¹¶æ ¹æ®å½“å‰workeræ•°é‡åˆ¤æ–­æ˜¯å¦éœ€è¦addWorker()
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //allowCoreThreadTimeOuté»˜è®¤ä¸ºfalseï¼Œå³miné»˜è®¤ä¸ºcorePoolSize
             
            //å¦‚æœminä¸º0ï¼Œå³ä¸éœ€è¦ç»´æŒæ ¸å¿ƒçº¿ç¨‹æ•°é‡ï¼Œä¸”workQueueä¸ä¸ºç©ºï¼Œè‡³å°‘ä¿æŒä¸€ä¸ªçº¿ç¨‹
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
             
            //å¦‚æœçº¿ç¨‹æ•°é‡å¤§äºæœ€å°‘æ•°é‡ï¼Œç›´æ¥è¿”å›ï¼Œå¦åˆ™ä¸‹é¢è‡³å°‘è¦addWorkerä¸€ä¸ª
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
         
        //æ·»åŠ ä¸€ä¸ªæ²¡æœ‰firstTaskçš„worker
        //åªè¦workeræ˜¯completedAbruptlyçªç„¶ç»ˆæ­¢çš„ï¼Œæˆ–è€…çº¿ç¨‹æ•°é‡å°äºè¦ç»´æŠ¤çš„æ•°é‡ï¼Œå°±æ–°æ·»ä¸€ä¸ªworkerçº¿ç¨‹ï¼Œå³ä½¿æ˜¯shutdownçŠ¶æ€
        addWorker(null, false);
    }
}

processWorkerExit(Worker w, boolean completedAbruptly)
å‚æ•°ï¼š
    workerï¼š                      è¦ç»“æŸçš„worker
    completedAbruptlyï¼š æ˜¯å¦çªç„¶å®Œæˆï¼ˆæ˜¯å¦å› ä¸ºå¼‚å¸¸é€€å‡ºï¼‰
æ‰§è¡Œæµç¨‹ï¼š
1ã€workeræ•°é‡-1
    Aã€å¦‚æœæ˜¯çªç„¶ç»ˆæ­¢ï¼Œè¯´æ˜æ˜¯taskæ‰§è¡Œæ—¶å¼‚å¸¸æƒ…å†µå¯¼è‡´ï¼Œå³run()æ–¹æ³•æ‰§è¡Œæ—¶å‘ç”Ÿäº†å¼‚å¸¸ï¼Œé‚£ä¹ˆæ­£åœ¨å·¥ä½œçš„workerçº¿ç¨‹æ•°é‡éœ€è¦-1
    Bã€å¦‚æœä¸æ˜¯çªç„¶ç»ˆæ­¢ï¼Œè¯´æ˜æ˜¯workerçº¿ç¨‹æ²¡æœ‰taskå¯æ‰§è¡Œäº†ï¼Œä¸ç”¨-1ï¼Œå› ä¸ºå·²ç»åœ¨getTask()æ–¹æ³•ä¸­-1äº†
2ã€ä»Workers Setä¸­ç§»é™¤workerï¼Œåˆ é™¤æ—¶éœ€è¦ä¸Šé”mainlock
3ã€tryTerminate()ï¼šåœ¨å¯¹çº¿ç¨‹æ± æœ‰è´Ÿæ•ˆç›Šçš„æ“ä½œæ—¶ï¼Œéƒ½éœ€è¦â€œå°è¯•ç»ˆæ­¢â€çº¿ç¨‹æ± ï¼Œå¤§æ¦‚é€»è¾‘ï¼š
    åˆ¤æ–­çº¿ç¨‹æ± æ˜¯å¦æ»¡è¶³ç»ˆæ­¢çš„çŠ¶æ€
    Aã€å¦‚æœçŠ¶æ€æ»¡è¶³ï¼Œä½†è¿˜æœ‰çº¿ç¨‹æ± è¿˜æœ‰çº¿ç¨‹ï¼Œå°è¯•å¯¹å…¶å‘å‡ºä¸­æ–­å“åº”ï¼Œä½¿å…¶èƒ½è¿›å…¥é€€å‡ºæµç¨‹
    Bã€æ²¡æœ‰çº¿ç¨‹äº†ï¼Œæ›´æ–°çŠ¶æ€ä¸ºtidying->terminated
4ã€æ˜¯å¦éœ€è¦å¢åŠ workerçº¿ç¨‹ï¼Œå¦‚æœçº¿ç¨‹æ± è¿˜æ²¡æœ‰å®Œå…¨ç»ˆæ­¢ï¼Œä»éœ€è¦ä¿æŒä¸€å®šæ•°é‡çš„çº¿ç¨‹
    çº¿ç¨‹æ± çŠ¶æ€æ˜¯running æˆ– shutdown
    Aã€å¦‚æœå½“å‰çº¿ç¨‹æ˜¯çªç„¶ç»ˆæ­¢çš„ï¼ŒaddWorker()
    Bã€å¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯çªç„¶ç»ˆæ­¢çš„ï¼Œä½†å½“å‰çº¿ç¨‹æ•°é‡ < è¦ç»´æŠ¤çš„çº¿ç¨‹æ•°é‡ï¼ŒaddWorker()
    æ•…å¦‚æœè°ƒç”¨çº¿ç¨‹æ± shutdown()ï¼Œç›´åˆ°workQueueä¸ºç©ºå‰ï¼Œçº¿ç¨‹æ± éƒ½ä¼šç»´æŒcorePoolSizeä¸ªçº¿ç¨‹ï¼Œç„¶åå†é€æ¸é”€æ¯è¿™corePoolSizeä¸ªçº¿ç¨‹
```





























