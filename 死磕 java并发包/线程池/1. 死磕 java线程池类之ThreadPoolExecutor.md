🖕欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。 

（手机横屏看源码更方便）

---
## 问题（选自经典面试题）
1. 几种常见的线程池有哪些，以及他们的使用场景
2. 线程池都有哪几种工作队列
3. 简单的描述一下线程池的工作原理

## 简介
**线程池** 是一种线程使用模式，同时也是一种池化技术。在java中，类似的池化技术有很多，例如jvm的String常量池，数据库连接池。
如果把此逻辑进行拓展，甚至连单例模式或者redis缓存也算是一种池化技术。而池化技术最初的目的，就是减少计算机的资源消耗。

JDK中的关于**并行执行任务的框架**主要有两个 Executor框架 和 fork-join框架 本章先拿Executor框架开刀。

对于Executor框架而言，最核心的就是ThreadPoolExecutor类。JDK提供的四大默认线程池就是由此类提供支持。

## 一个线程池的小例子
````
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TestThreadPool {

    public static void main(String[] args) {
        //初始化ThreadPoolExecutor类，这里给ThreadPoolExecutor类提供很多很多参数
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5));

        for(int i=0;i<12;i++){
            //定义了一个任务
            Task task = new Task(i);
            //往这个池进行提交任务，可以把这个池当成一个工人，“把一个完完整整的活丢给了一个工人”
            executor.execute(task);
            //打印一些线程池的信息，就单纯的查看一下
            System.out.println("线程池中线程数目："+executor.getPoolSize()+"，队列中等待执行的任务数目："+ executor.getQueue().size()+"，已执行的任务数目："+executor.getCompletedTaskCount());
        }
        //关闭线程池，不再接受submit
        executor.shutdown();
    }
}


class Task implements Runnable {
    private int num;

    public Task(int num) {
        this.num = num;
    }
    @Override
    public void run() {
        System.out.println("正在执行task "+num);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task "+num+"执行完毕");
    }
}
````

从这个最基础的场景类可以看出，线程池的一般运作方式有

1. 初始化线程池，通过参数配置线程池的各种行为
2. 往线程池内提交task
3. 关闭线程池

那么接下来就一步一步的进入到ThreadPoolExecutor内部查看到底这个类是怎么运作的

## 之后的小节的目录大纲

1. ThreadPoolExecutor的继承关系图，重要父类，接口的关系，一些重要方法
2. ThreadPoolExecutor类的重要field
       + 线程池的状态相关field
       + 线程池的执行方法相关的核心field
       + 线程池的辅助性支持field与inner class
3. ThreadPoolExecutor类构造方法
4. ThreadPoolExecutor类的核心方法(核心逻辑)
       + 线程池的线程提交
       + 线程池内线程初始化
       + 线程池的任务缓存队列及排队策略
       + 线程池的任务拒绝策略
       + 线程池容量的动态调整
5. 线程池的关闭
6. ThreadPoolExecutor类和JDK提供的四个线程池关系
6. 全量源码注释

## 1. ThreadPoolExecutor的继承关系图

从图内可以大致知道这样的继承关系

1. Executor是一个顶层接口，打开这个接口后发现只有一个方法,此方法就是用来执行传进去的任务的
````
public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     * 1. 执行给定的指令(Runnable 实现类)
     * 2. 此指令将会在新开线程内,线程池内,带有返回的线程内执行
     */
    void execute(Runnable command);
}
````
2. 接下来ExecutorService接口继承了Executor接口，打开并摘取一部分重要的方法
````
public interface ExecutorService extends Executor {
    // 线程池关闭，线程池里的线程就随它去
    void shutdown();
    
    //立刻停止！马上！正在执行的给我立马停！那些个没执行的返回来
    List<Runnable> shutdownNow();
    
    //判断线程池是不是被停了
    boolean isShutdown();

    //判断关闭（调用shutdown方法之后）线程池里面的线程是不是执行完了
    boolean isTerminated();

    //调用此方法之后就一直等待着线程池里面的线程执行完了之后，才能继续，两个参数控制等待的行为
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

     //好重要好重要的一个方法，用来提交有返回值的线程
    <T> Future<T> submit(Callable<T> task);

    //提交一个线程，指定一个结果，当线程完成的时候返回自定义的结果
    //相当于submit(Callable<T> task) 的另外一种实现
    <T> Future<T> submit(Runnable task, T result);

    //提交一个runnable 的线程，执行完了就返回null(Future.get()之后返回)
    //是不是觉得没啥意义~~意义当然有
    //返回的是一个Future，当调用get(),代码就会卡在那，等着返回
    //返回的即是是null,我也不care，目的只有“我知道这个任务已经结束了，可以开始下面的事情了”
    Future<?> submit(Runnable task);

    //相当于批量的submit(Callable<T> task)方法，一口气把想执行的callable task丢进线程池里面
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    //在批量提交的方法上增加时间相关的参数
    //如果超时，那么list里面的某个任务会被取消
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    //提交一大堆的线程，这么多线程里面一个成功就可以，只要给我一个返回值
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    //这个道理类似，就是在invokeAny(Collection<? extends Callable<T>> tasks) 上增加时间的控制
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
````
3. 那么再然后就是AbstractExecutorService 这个类基本上实现了ExecutorService的行为，具体再细节的东西我们在他的子类里面详细的说
请记住这个男人 Doug Lea ！这个类就是这个人写的
4. 最重要的压轴类就是ThreadPoolExecutor，这个类继承了AbstractExecutorService类

## 2. ThreadPoolExecutor类的重要field

ThreadPoolExecutor类 是一个很大的类，里面的行为逻辑线条很多，因此在后期的说明中会辅以大量的流程图进行表示。

类的field的数量也多的吓人，因此在逻辑上我们先将全部的核心逻辑相关的field按照功能进行划分，一一击破即可。

### 按照功能划分-线程池的状态

 首先奉上各种线程池状态的迁移图及其关系

````
    //定一个常量，在之后定义状态值是使用
    private static final int COUNT_BITS = Integer.SIZE - 3;

    //线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
    //线程池的初始化状态是RUNNING。当线程池被一旦被创建，就处于RUNNING状态，这个时候线程池中的任务数为0
    private static final int RUNNING    = -1 << COUNT_BITS;

    //如果调用了shutdown()方法，则线程池处于SHUTDOWN状态
    //线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
    private static final int SHUTDOWN   =  0 << COUNT_BITS;

    //如果调用了shutdownNow()方法，则线程池处于STOP状态
    //线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
    private static final int STOP       =  1 << COUNT_BITS;

    //当所有的任务已终止，当前类记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()
    private static final int TIDYING    =  2 << COUNT_BITS;

    //线程池彻底终止，就变成TERMINATED状态。 
    private static final int TERMINATED =  3 << COUNT_BITS;
````

### 线程池的执行方法相关的核心field
还是先祭出一波所有的field列表
在这里面我们挑选重要的成员变量进行说明
````
    //以下6个成员变量直接由构造方法传入

    //核心池的大小，当线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列
    private volatile int corePoolSize;                  //1
    private volatile int maximumPoolSize;               //2 线程池最大能容忍的线程数
    private final BlockingQueue<Runnable> workQueue;    //3 任务缓存队列，用来存放等待执行的任务
    private volatile long keepAliveTime;                //4 线程存活时间
    private volatile ThreadFactory threadFactory;       //5 线程工厂，用来创建线程
    private volatile RejectedExecutionHandler handler;  //6 任务拒绝策略

    private long completedTaskCount;        //用来记录已经执行完毕的任务个数
    private volatile int   poolSize;        //线程池中当前的线程数
    private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间
    private final HashSet<Worker> workers = new HashSet<Worker>();  //用来存放工作集
    private final ReentrantLock mainLock = new ReentrantLock();     //线程池的主要状态锁 很多方法强烈依赖于这个锁

````

### 线程池的辅助性支持field与inner class
````
//此原子类记录 "任务数量"的概念,ThreadPoolExecutor类内有一部分function专门去处理ctl
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//用来存放工作集
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {...}
//以下四个inner类可以观察到都实现了RejectedExecutionHandler接口，这就是拒绝策略实体类
//是直接定义到ThreadPoolExecutor类内的
public static class CallerRunsPolicy implements RejectedExecutionHandler {...}
public static class AbortPolicy implements RejectedExecutionHandler {...}
public static class DiscardPolicy implements RejectedExecutionHandler {...}
public static class DiscardOldestPolicy implements RejectedExecutionHandler {...}
````

## ThreadPoolExecutor类构造方法
ThreadPoolExecutor类构造方法 的构造方法总共有四个，有些参数可以缺省，那么就用默认的代替，最终调用的就是下面所看到的构造方法
````
    // 这些参数代表什么已经在上个小节内叨叨过了，在此不再重复，只关心构造函数内的逻辑
    // ThreadFactory 可以缺省，代替为Executors.defaultThreadFactory()
    // RejectedExecutionHandler 可以缺省 代替为 ThreadPoolExecutor.defaultHandler(内部类AbortPolicy的实例)
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,
                              TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        /**
         * 1. 检查数值型的入参是否符合要求
         * 2. 检查引用类型入参是否符合要求，只要一个null就抛异常
         * 3. 该赋值的就赋值，各回各家，各找爹妈
         * 4. keepAliveTime 通过TimeUnit(时间类型)和 keepAliveTime(时间数值)最终确定标准类型的时间长度
         * */
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
````
## ThreadPoolExecutor类的核心方法(核心逻辑)
### 提交任务
从ExecutorService接口定义可以发现，提交任务的方式是有很多的，然而最终都和顶级接口定义的execute()方法分不开

因此我们以这个为突破口，刚好，前面小节内提供的小案例就是使用execute()方法提交的任务
````
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
````