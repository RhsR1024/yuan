ğŸ–•æ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å·â€œå½¤å“¥è¯»æºç â€ï¼ŒæŸ¥çœ‹æ›´å¤šæºç ç³»åˆ—æ–‡ç« , ä¸å½¤å“¥ä¸€èµ·ç•…æ¸¸æºç çš„æµ·æ´‹ã€‚ 

ï¼ˆæ‰‹æœºæ¨ªå±çœ‹æºç æ›´æ–¹ä¾¿ï¼‰

---
## é—®é¢˜ï¼ˆé€‰è‡ªç»å…¸é¢è¯•é¢˜ï¼‰
1. å‡ ç§å¸¸è§çš„çº¿ç¨‹æ± æœ‰å“ªäº›ï¼Œä»¥åŠä»–ä»¬çš„ä½¿ç”¨åœºæ™¯
2. çº¿ç¨‹æ± éƒ½æœ‰å“ªå‡ ç§å·¥ä½œé˜Ÿåˆ—
3. ç®€å•çš„æè¿°ä¸€ä¸‹çº¿ç¨‹æ± çš„å·¥ä½œåŸç†

## ç®€ä»‹
**çº¿ç¨‹æ± ** æ˜¯ä¸€ç§çº¿ç¨‹ä½¿ç”¨æ¨¡å¼ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ç§æ± åŒ–æŠ€æœ¯ã€‚åœ¨javaä¸­ï¼Œç±»ä¼¼çš„æ± åŒ–æŠ€æœ¯æœ‰å¾ˆå¤šï¼Œä¾‹å¦‚jvmçš„Stringå¸¸é‡æ± ï¼Œæ•°æ®åº“è¿æ¥æ± ã€‚
å¦‚æœæŠŠæ­¤é€»è¾‘è¿›è¡Œæ‹“å±•ï¼Œç”šè‡³è¿å•ä¾‹æ¨¡å¼æˆ–è€…redisç¼“å­˜ä¹Ÿç®—æ˜¯ä¸€ç§æ± åŒ–æŠ€æœ¯ã€‚è€Œæ± åŒ–æŠ€æœ¯æœ€åˆçš„ç›®çš„ï¼Œå°±æ˜¯å‡å°‘è®¡ç®—æœºçš„èµ„æºæ¶ˆè€—ã€‚

JDKä¸­çš„å…³äº**å¹¶è¡Œæ‰§è¡Œä»»åŠ¡çš„æ¡†æ¶**ä¸»è¦æœ‰ä¸¤ä¸ª Executoræ¡†æ¶ å’Œ fork-joinæ¡†æ¶ æœ¬ç« å…ˆæ‹¿Executoræ¡†æ¶å¼€åˆ€ã€‚

å¯¹äºExecutoræ¡†æ¶è€Œè¨€ï¼Œæœ€æ ¸å¿ƒçš„å°±æ˜¯ThreadPoolExecutorç±»ã€‚JDKæä¾›çš„å››å¤§é»˜è®¤çº¿ç¨‹æ± å°±æ˜¯ç”±æ­¤ç±»æä¾›æ”¯æŒã€‚

## ä¸€ä¸ªçº¿ç¨‹æ± çš„å°ä¾‹å­
````
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TestThreadPool {

    public static void main(String[] args) {
        //åˆå§‹åŒ–ThreadPoolExecutorç±»ï¼Œè¿™é‡Œç»™ThreadPoolExecutorç±»æä¾›å¾ˆå¤šå¾ˆå¤šå‚æ•°
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5));

        for(int i=0;i<12;i++){
            //å®šä¹‰äº†ä¸€ä¸ªä»»åŠ¡
            Task task = new Task(i);
            //å¾€è¿™ä¸ªæ± è¿›è¡Œæäº¤ä»»åŠ¡ï¼Œå¯ä»¥æŠŠè¿™ä¸ªæ± å½“æˆä¸€ä¸ªå·¥äººï¼Œâ€œæŠŠä¸€ä¸ªå®Œå®Œæ•´æ•´çš„æ´»ä¸¢ç»™äº†ä¸€ä¸ªå·¥äººâ€
            executor.execute(task);
            //æ‰“å°ä¸€äº›çº¿ç¨‹æ± çš„ä¿¡æ¯ï¼Œå°±å•çº¯çš„æŸ¥çœ‹ä¸€ä¸‹
            System.out.println("çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°ç›®ï¼š"+executor.getPoolSize()+"ï¼Œé˜Ÿåˆ—ä¸­ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡æ•°ç›®ï¼š"+ executor.getQueue().size()+"ï¼Œå·²æ‰§è¡Œçš„ä»»åŠ¡æ•°ç›®ï¼š"+executor.getCompletedTaskCount());
        }
        //å…³é—­çº¿ç¨‹æ± ï¼Œä¸å†æ¥å—submit
        executor.shutdown();
    }
}


class Task implements Runnable {
    private int num;

    public Task(int num) {
        this.num = num;
    }
    @Override
    public void run() {
        System.out.println("æ­£åœ¨æ‰§è¡Œtask "+num);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task "+num+"æ‰§è¡Œå®Œæ¯•");
    }
}
````

ä»è¿™ä¸ªæœ€åŸºç¡€çš„åœºæ™¯ç±»å¯ä»¥çœ‹å‡ºï¼Œçº¿ç¨‹æ± çš„ä¸€èˆ¬è¿ä½œæ–¹å¼æœ‰

1. åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œé€šè¿‡å‚æ•°é…ç½®çº¿ç¨‹æ± çš„å„ç§è¡Œä¸º
2. å¾€çº¿ç¨‹æ± å†…æäº¤task
3. å…³é—­çº¿ç¨‹æ± 

é‚£ä¹ˆæ¥ä¸‹æ¥å°±ä¸€æ­¥ä¸€æ­¥çš„è¿›å…¥åˆ°ThreadPoolExecutorå†…éƒ¨æŸ¥çœ‹åˆ°åº•è¿™ä¸ªç±»æ˜¯æ€ä¹ˆè¿ä½œçš„

## ä¹‹åçš„å°èŠ‚çš„ç›®å½•å¤§çº²

1. ThreadPoolExecutorçš„ç»§æ‰¿å…³ç³»å›¾ï¼Œé‡è¦çˆ¶ç±»ï¼Œæ¥å£çš„å…³ç³»ï¼Œä¸€äº›é‡è¦æ–¹æ³•
2. ThreadPoolExecutorç±»çš„é‡è¦field
       + çº¿ç¨‹æ± çš„çŠ¶æ€ç›¸å…³field
       + çº¿ç¨‹æ± çš„æ‰§è¡Œæ–¹æ³•ç›¸å…³çš„æ ¸å¿ƒfield
       + çº¿ç¨‹æ± çš„è¾…åŠ©æ€§æ”¯æŒfieldä¸inner class
3. ThreadPoolExecutorç±»æ„é€ æ–¹æ³•
4. ThreadPoolExecutorç±»çš„æ ¸å¿ƒæ–¹æ³•(æ ¸å¿ƒé€»è¾‘)
       + çº¿ç¨‹æ± çš„çº¿ç¨‹æäº¤
       + çº¿ç¨‹æ± å†…çº¿ç¨‹åˆå§‹åŒ–
       + çº¿ç¨‹æ± çš„ä»»åŠ¡ç¼“å­˜é˜Ÿåˆ—åŠæ’é˜Ÿç­–ç•¥
       + çº¿ç¨‹æ± çš„ä»»åŠ¡æ‹’ç»ç­–ç•¥
       + çº¿ç¨‹æ± å®¹é‡çš„åŠ¨æ€è°ƒæ•´
5. çº¿ç¨‹æ± çš„å…³é—­
6. ThreadPoolExecutorç±»å’ŒJDKæä¾›çš„å››ä¸ªçº¿ç¨‹æ± å…³ç³»
6. å…¨é‡æºç æ³¨é‡Š

## 1. ThreadPoolExecutorçš„ç»§æ‰¿å…³ç³»å›¾

ä»å›¾å†…å¯ä»¥å¤§è‡´çŸ¥é“è¿™æ ·çš„ç»§æ‰¿å…³ç³»

1. Executoræ˜¯ä¸€ä¸ªé¡¶å±‚æ¥å£ï¼Œæ‰“å¼€è¿™ä¸ªæ¥å£åå‘ç°åªæœ‰ä¸€ä¸ªæ–¹æ³•,æ­¤æ–¹æ³•å°±æ˜¯ç”¨æ¥æ‰§è¡Œä¼ è¿›å»çš„ä»»åŠ¡çš„
````
public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     * 1. æ‰§è¡Œç»™å®šçš„æŒ‡ä»¤(Runnable å®ç°ç±»)
     * 2. æ­¤æŒ‡ä»¤å°†ä¼šåœ¨æ–°å¼€çº¿ç¨‹å†…,çº¿ç¨‹æ± å†…,å¸¦æœ‰è¿”å›çš„çº¿ç¨‹å†…æ‰§è¡Œ
     */
    void execute(Runnable command);
}
````
2. æ¥ä¸‹æ¥ExecutorServiceæ¥å£ç»§æ‰¿äº†Executoræ¥å£ï¼Œæ‰“å¼€å¹¶æ‘˜å–ä¸€éƒ¨åˆ†é‡è¦çš„æ–¹æ³•
````
public interface ExecutorService extends Executor {
    // çº¿ç¨‹æ± å…³é—­ï¼Œçº¿ç¨‹æ± é‡Œçš„çº¿ç¨‹å°±éšå®ƒå»
    void shutdown();
    
    //ç«‹åˆ»åœæ­¢ï¼é©¬ä¸Šï¼æ­£åœ¨æ‰§è¡Œçš„ç»™æˆ‘ç«‹é©¬åœï¼é‚£äº›ä¸ªæ²¡æ‰§è¡Œçš„è¿”å›æ¥
    List<Runnable> shutdownNow();
    
    //åˆ¤æ–­çº¿ç¨‹æ± æ˜¯ä¸æ˜¯è¢«åœäº†
    boolean isShutdown();

    //åˆ¤æ–­å…³é—­ï¼ˆè°ƒç”¨shutdownæ–¹æ³•ä¹‹åï¼‰çº¿ç¨‹æ± é‡Œé¢çš„çº¿ç¨‹æ˜¯ä¸æ˜¯æ‰§è¡Œå®Œäº†
    boolean isTerminated();

    //è°ƒç”¨æ­¤æ–¹æ³•ä¹‹åå°±ä¸€ç›´ç­‰å¾…ç€çº¿ç¨‹æ± é‡Œé¢çš„çº¿ç¨‹æ‰§è¡Œå®Œäº†ä¹‹åï¼Œæ‰èƒ½ç»§ç»­ï¼Œä¸¤ä¸ªå‚æ•°æ§åˆ¶ç­‰å¾…çš„è¡Œä¸º
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

     //å¥½é‡è¦å¥½é‡è¦çš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨æ¥æäº¤æœ‰è¿”å›å€¼çš„çº¿ç¨‹
    <T> Future<T> submit(Callable<T> task);

    //æäº¤ä¸€ä¸ªçº¿ç¨‹ï¼ŒæŒ‡å®šä¸€ä¸ªç»“æœï¼Œå½“çº¿ç¨‹å®Œæˆçš„æ—¶å€™è¿”å›è‡ªå®šä¹‰çš„ç»“æœ
    //ç›¸å½“äºsubmit(Callable<T> task) çš„å¦å¤–ä¸€ç§å®ç°
    <T> Future<T> submit(Runnable task, T result);

    //æäº¤ä¸€ä¸ªrunnable çš„çº¿ç¨‹ï¼Œæ‰§è¡Œå®Œäº†å°±è¿”å›null(Future.get()ä¹‹åè¿”å›)
    //æ˜¯ä¸æ˜¯è§‰å¾—æ²¡å•¥æ„ä¹‰~~æ„ä¹‰å½“ç„¶æœ‰
    //è¿”å›çš„æ˜¯ä¸€ä¸ªFutureï¼Œå½“è°ƒç”¨get(),ä»£ç å°±ä¼šå¡åœ¨é‚£ï¼Œç­‰ç€è¿”å›
    //è¿”å›çš„å³æ˜¯æ˜¯null,æˆ‘ä¹Ÿä¸careï¼Œç›®çš„åªæœ‰â€œæˆ‘çŸ¥é“è¿™ä¸ªä»»åŠ¡å·²ç»ç»“æŸäº†ï¼Œå¯ä»¥å¼€å§‹ä¸‹é¢çš„äº‹æƒ…äº†â€
    Future<?> submit(Runnable task);

    //ç›¸å½“äºæ‰¹é‡çš„submit(Callable<T> task)æ–¹æ³•ï¼Œä¸€å£æ°”æŠŠæƒ³æ‰§è¡Œçš„callable taskä¸¢è¿›çº¿ç¨‹æ± é‡Œé¢
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    //åœ¨æ‰¹é‡æäº¤çš„æ–¹æ³•ä¸Šå¢åŠ æ—¶é—´ç›¸å…³çš„å‚æ•°
    //å¦‚æœè¶…æ—¶ï¼Œé‚£ä¹ˆlisté‡Œé¢çš„æŸä¸ªä»»åŠ¡ä¼šè¢«å–æ¶ˆ
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    //æäº¤ä¸€å¤§å †çš„çº¿ç¨‹ï¼Œè¿™ä¹ˆå¤šçº¿ç¨‹é‡Œé¢ä¸€ä¸ªæˆåŠŸå°±å¯ä»¥ï¼Œåªè¦ç»™æˆ‘ä¸€ä¸ªè¿”å›å€¼
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    //è¿™ä¸ªé“ç†ç±»ä¼¼ï¼Œå°±æ˜¯åœ¨invokeAny(Collection<? extends Callable<T>> tasks) ä¸Šå¢åŠ æ—¶é—´çš„æ§åˆ¶
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
````
3. é‚£ä¹ˆå†ç„¶åå°±æ˜¯AbstractExecutorService è¿™ä¸ªç±»åŸºæœ¬ä¸Šå®ç°äº†ExecutorServiceçš„è¡Œä¸ºï¼Œå…·ä½“å†ç»†èŠ‚çš„ä¸œè¥¿æˆ‘ä»¬åœ¨ä»–çš„å­ç±»é‡Œé¢è¯¦ç»†çš„è¯´
è¯·è®°ä½è¿™ä¸ªç”·äºº Doug Lea ï¼è¿™ä¸ªç±»å°±æ˜¯è¿™ä¸ªäººå†™çš„
4. æœ€é‡è¦çš„å‹è½´ç±»å°±æ˜¯ThreadPoolExecutorï¼Œè¿™ä¸ªç±»ç»§æ‰¿äº†AbstractExecutorServiceç±»

## 2. ThreadPoolExecutorç±»çš„é‡è¦field

ThreadPoolExecutorç±» æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„ç±»ï¼Œé‡Œé¢çš„è¡Œä¸ºé€»è¾‘çº¿æ¡å¾ˆå¤šï¼Œå› æ­¤åœ¨åæœŸçš„è¯´æ˜ä¸­ä¼šè¾…ä»¥å¤§é‡çš„æµç¨‹å›¾è¿›è¡Œè¡¨ç¤ºã€‚

ç±»çš„fieldçš„æ•°é‡ä¹Ÿå¤šçš„å“äººï¼Œå› æ­¤åœ¨é€»è¾‘ä¸Šæˆ‘ä»¬å…ˆå°†å…¨éƒ¨çš„æ ¸å¿ƒé€»è¾‘ç›¸å…³çš„fieldæŒ‰ç…§åŠŸèƒ½è¿›è¡Œåˆ’åˆ†ï¼Œä¸€ä¸€å‡»ç ´å³å¯ã€‚

### æŒ‰ç…§åŠŸèƒ½åˆ’åˆ†-çº¿ç¨‹æ± çš„çŠ¶æ€

 é¦–å…ˆå¥‰ä¸Šå„ç§çº¿ç¨‹æ± çŠ¶æ€çš„è¿ç§»å›¾åŠå…¶å…³ç³»

````
    //å®šä¸€ä¸ªå¸¸é‡ï¼Œåœ¨ä¹‹åå®šä¹‰çŠ¶æ€å€¼æ˜¯ä½¿ç”¨
    private static final int COUNT_BITS = Integer.SIZE - 3;

    //çº¿ç¨‹æ± å¤„åœ¨RUNNINGçŠ¶æ€æ—¶ï¼Œèƒ½å¤Ÿæ¥æ”¶æ–°ä»»åŠ¡ï¼Œä»¥åŠå¯¹å·²æ·»åŠ çš„ä»»åŠ¡è¿›è¡Œå¤„ç†ã€‚
    //çº¿ç¨‹æ± çš„åˆå§‹åŒ–çŠ¶æ€æ˜¯RUNNINGã€‚å½“çº¿ç¨‹æ± è¢«ä¸€æ—¦è¢«åˆ›å»ºï¼Œå°±å¤„äºRUNNINGçŠ¶æ€ï¼Œè¿™ä¸ªæ—¶å€™çº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡æ•°ä¸º0
    private static final int RUNNING    = -1 << COUNT_BITS;

    //å¦‚æœè°ƒç”¨äº†shutdown()æ–¹æ³•ï¼Œåˆ™çº¿ç¨‹æ± å¤„äºSHUTDOWNçŠ¶æ€
    //çº¿ç¨‹æ± å¤„åœ¨SHUTDOWNçŠ¶æ€æ—¶ï¼Œä¸æ¥æ”¶æ–°ä»»åŠ¡ï¼Œä½†èƒ½å¤„ç†å·²æ·»åŠ çš„ä»»åŠ¡ã€‚
    private static final int SHUTDOWN   =  0 << COUNT_BITS;

    //å¦‚æœè°ƒç”¨äº†shutdownNow()æ–¹æ³•ï¼Œåˆ™çº¿ç¨‹æ± å¤„äºSTOPçŠ¶æ€
    //çº¿ç¨‹æ± å¤„åœ¨STOPçŠ¶æ€æ—¶ï¼Œä¸æ¥æ”¶æ–°ä»»åŠ¡ï¼Œä¸å¤„ç†å·²æ·»åŠ çš„ä»»åŠ¡ï¼Œå¹¶ä¸”ä¼šä¸­æ–­æ­£åœ¨å¤„ç†çš„ä»»åŠ¡ã€‚
    private static final int STOP       =  1 << COUNT_BITS;

    //å½“æ‰€æœ‰çš„ä»»åŠ¡å·²ç»ˆæ­¢ï¼Œå½“å‰ç±»è®°å½•çš„â€ä»»åŠ¡æ•°é‡â€ä¸º0ï¼Œçº¿ç¨‹æ± ä¼šå˜ä¸ºTIDYINGçŠ¶æ€ã€‚å½“çº¿ç¨‹æ± å˜ä¸ºTIDYINGçŠ¶æ€æ—¶ï¼Œä¼šæ‰§è¡Œé’©å­å‡½æ•°terminated()
    private static final int TIDYING    =  2 << COUNT_BITS;

    //çº¿ç¨‹æ± å½»åº•ç»ˆæ­¢ï¼Œå°±å˜æˆTERMINATEDçŠ¶æ€ã€‚ 
    private static final int TERMINATED =  3 << COUNT_BITS;
````

### çº¿ç¨‹æ± çš„æ‰§è¡Œæ–¹æ³•ç›¸å…³çš„æ ¸å¿ƒfield
è¿˜æ˜¯å…ˆç¥­å‡ºä¸€æ³¢æ‰€æœ‰çš„fieldåˆ—è¡¨
åœ¨è¿™é‡Œé¢æˆ‘ä»¬æŒ‘é€‰é‡è¦çš„æˆå‘˜å˜é‡è¿›è¡Œè¯´æ˜
````
    //ä»¥ä¸‹6ä¸ªæˆå‘˜å˜é‡ç›´æ¥ç”±æ„é€ æ–¹æ³•ä¼ å…¥

    //æ ¸å¿ƒæ± çš„å¤§å°ï¼Œå½“çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°ç›®å¤§äºè¿™ä¸ªå‚æ•°æ—¶ï¼Œæäº¤çš„ä»»åŠ¡ä¼šè¢«æ”¾è¿›ä»»åŠ¡ç¼“å­˜é˜Ÿåˆ—
    private volatile int corePoolSize;                  //1
    private volatile int maximumPoolSize;               //2 çº¿ç¨‹æ± æœ€å¤§èƒ½å®¹å¿çš„çº¿ç¨‹æ•°
    private final BlockingQueue<Runnable> workQueue;    //3 ä»»åŠ¡ç¼“å­˜é˜Ÿåˆ—ï¼Œç”¨æ¥å­˜æ”¾ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡
    private volatile long keepAliveTime;                //4 çº¿ç¨‹å­˜æ´»æ—¶é—´
    private volatile ThreadFactory threadFactory;       //5 çº¿ç¨‹å·¥å‚ï¼Œç”¨æ¥åˆ›å»ºçº¿ç¨‹
    private volatile RejectedExecutionHandler handler;  //6 ä»»åŠ¡æ‹’ç»ç­–ç•¥

    private long completedTaskCount;        //ç”¨æ¥è®°å½•å·²ç»æ‰§è¡Œå®Œæ¯•çš„ä»»åŠ¡ä¸ªæ•°
    private volatile int   poolSize;        //çº¿ç¨‹æ± ä¸­å½“å‰çš„çº¿ç¨‹æ•°
    private volatile boolean allowCoreThreadTimeOut;   //æ˜¯å¦å…è®¸ä¸ºæ ¸å¿ƒçº¿ç¨‹è®¾ç½®å­˜æ´»æ—¶é—´
    private final HashSet<Worker> workers = new HashSet<Worker>();  //ç”¨æ¥å­˜æ”¾å·¥ä½œé›†
    private final ReentrantLock mainLock = new ReentrantLock();     //çº¿ç¨‹æ± çš„ä¸»è¦çŠ¶æ€é” å¾ˆå¤šæ–¹æ³•å¼ºçƒˆä¾èµ–äºè¿™ä¸ªé”

````

### çº¿ç¨‹æ± çš„è¾…åŠ©æ€§æ”¯æŒfieldä¸inner class
````
//æ­¤åŸå­ç±»è®°å½• "ä»»åŠ¡æ•°é‡"çš„æ¦‚å¿µ,ThreadPoolExecutorç±»å†…æœ‰ä¸€éƒ¨åˆ†functionä¸“é—¨å»å¤„ç†ctl
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//ç”¨æ¥å­˜æ”¾å·¥ä½œé›†
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {...}
//ä»¥ä¸‹å››ä¸ªinnerç±»å¯ä»¥è§‚å¯Ÿåˆ°éƒ½å®ç°äº†RejectedExecutionHandleræ¥å£ï¼Œè¿™å°±æ˜¯æ‹’ç»ç­–ç•¥å®ä½“ç±»
//æ˜¯ç›´æ¥å®šä¹‰åˆ°ThreadPoolExecutorç±»å†…çš„
public static class CallerRunsPolicy implements RejectedExecutionHandler {...}
public static class AbortPolicy implements RejectedExecutionHandler {...}
public static class DiscardPolicy implements RejectedExecutionHandler {...}
public static class DiscardOldestPolicy implements RejectedExecutionHandler {...}
````

## ThreadPoolExecutorç±»æ„é€ æ–¹æ³•
ThreadPoolExecutorç±»æ„é€ æ–¹æ³• çš„æ„é€ æ–¹æ³•æ€»å…±æœ‰å››ä¸ªï¼Œæœ‰äº›å‚æ•°å¯ä»¥ç¼ºçœï¼Œé‚£ä¹ˆå°±ç”¨é»˜è®¤çš„ä»£æ›¿ï¼Œæœ€ç»ˆè°ƒç”¨çš„å°±æ˜¯ä¸‹é¢æ‰€çœ‹åˆ°çš„æ„é€ æ–¹æ³•
````
    // è¿™äº›å‚æ•°ä»£è¡¨ä»€ä¹ˆå·²ç»åœ¨ä¸Šä¸ªå°èŠ‚å†…å¨å¨è¿‡äº†ï¼Œåœ¨æ­¤ä¸å†é‡å¤ï¼Œåªå…³å¿ƒæ„é€ å‡½æ•°å†…çš„é€»è¾‘
    // ThreadFactory å¯ä»¥ç¼ºçœï¼Œä»£æ›¿ä¸ºExecutors.defaultThreadFactory()
    // RejectedExecutionHandler å¯ä»¥ç¼ºçœ ä»£æ›¿ä¸º ThreadPoolExecutor.defaultHandler(å†…éƒ¨ç±»AbortPolicyçš„å®ä¾‹)
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,
                              TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        /**
         * 1. æ£€æŸ¥æ•°å€¼å‹çš„å…¥å‚æ˜¯å¦ç¬¦åˆè¦æ±‚
         * 2. æ£€æŸ¥å¼•ç”¨ç±»å‹å…¥å‚æ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œåªè¦ä¸€ä¸ªnullå°±æŠ›å¼‚å¸¸
         * 3. è¯¥èµ‹å€¼çš„å°±èµ‹å€¼ï¼Œå„å›å„å®¶ï¼Œå„æ‰¾çˆ¹å¦ˆ
         * 4. keepAliveTime é€šè¿‡TimeUnit(æ—¶é—´ç±»å‹)å’Œ keepAliveTime(æ—¶é—´æ•°å€¼)æœ€ç»ˆç¡®å®šæ ‡å‡†ç±»å‹çš„æ—¶é—´é•¿åº¦
         * */
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
````
## ThreadPoolExecutorç±»çš„æ ¸å¿ƒæ–¹æ³•(æ ¸å¿ƒé€»è¾‘)
### æäº¤ä»»åŠ¡
ä»ExecutorServiceæ¥å£å®šä¹‰å¯ä»¥å‘ç°ï¼Œæäº¤ä»»åŠ¡çš„æ–¹å¼æ˜¯æœ‰å¾ˆå¤šçš„ï¼Œç„¶è€Œæœ€ç»ˆéƒ½å’Œé¡¶çº§æ¥å£å®šä¹‰çš„execute()æ–¹æ³•åˆ†ä¸å¼€

å› æ­¤æˆ‘ä»¬ä»¥è¿™ä¸ªä¸ºçªç ´å£ï¼Œåˆšå¥½ï¼Œå‰é¢å°èŠ‚å†…æä¾›çš„å°æ¡ˆä¾‹å°±æ˜¯ä½¿ç”¨execute()æ–¹æ³•æäº¤çš„ä»»åŠ¡
````
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
````