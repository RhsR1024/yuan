🖕欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。 

（手机横屏看源码更方便）

---
## 问题（选自经典面试题）
1. 几种常见的线程池有哪些，以及他们的使用场景
2. 线程池都有哪几种工作队列
3. 简单的描述一下线程池的工作原理

## 简介
**线程池** 是一种线程使用模式，同时也是一种池化技术。在java中，类似的池化技术有很多，例如jvm的String常量池，数据库连接池。
如果把此逻辑进行拓展，甚至连单例模式或者redis缓存也算是一种池化技术。而池化技术最初的目的，就是减少计算机的资源消耗。

JDK中的关于**并行执行任务的框架**主要有两个 Executor框架 和 fork-join框架 本章先拿Executor框架开刀。

对于Executor框架而言，最核心的就是ThreadPoolExecutor类。JDK提供的四大默认线程池就是由此类提供支持。

## 一个线程池的小例子
```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TestThreadPool {

    public static void main(String[] args) {
        //初始化ThreadPoolExecutor类，这里给ThreadPoolExecutor类提供很多很多参数
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5));

        for(int i=0;i<12;i++){
            //定义了一个任务
            Task task = new Task(i);
            //往这个池进行提交任务，可以把这个池当成一个工人，“把一个完完整整的活丢给了一个工人”
            executor.execute(task);
            //打印一些线程池的信息，就单纯的查看一下
            System.out.println("线程池中线程数目："+executor.getPoolSize()+"，队列中等待执行的任务数目："+ executor.getQueue().size()+"，已执行的任务数目："+executor.getCompletedTaskCount());
        }
        //关闭线程池，不再接受submit
        executor.shutdown();
    }
}


class Task implements Runnable {
    private int num;

    public Task(int num) {
        this.num = num;
    }
    @Override
    public void run() {
        System.out.println("正在执行task "+num);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task "+num+"执行完毕");
    }
}
```

从这个最基础的场景类可以看出，线程池的一般运作方式有

1. 初始化线程池，通过参数配置线程池的各种行为
2. 往线程池内提交task
3. 关闭线程池

那么接下来就一步一步的进入到ThreadPoolExecutor内部查看到底这个类是怎么运作的

## 之后的小节的目录大纲

1. ThreadPoolExecutor的继承关系图，重要父类，接口的关系，一些重要方法
2. ThreadPoolExecutor类的重要field
       + 线程池的状态相关field
       + 线程池的执行方法相关的核心field
       + 线程池的辅助性支持field与inner class
3. ThreadPoolExecutor类构造方法
4. ThreadPoolExecutor类的核心方法(核心逻辑)
       + 线程池的线程提交
       + 线程池内线程初始化
       + 线程池的任务缓存队列及排队策略
       + 线程池的任务拒绝策略
       + 线程池容量的动态调整
5. 线程池的关闭
6. ThreadPoolExecutor类和JDK提供的四个线程池关系
6. 全量源码注释

## 1. ThreadPoolExecutor的继承关系图

从图内可以大致知道这样的继承关系

1. Executor是一个顶层接口，打开这个接口后发现只有一个方法,此方法就是用来执行传进去的任务的
```java
public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     * 1. 执行给定的指令(Runnable 实现类)
     * 2. 此指令将会在新开线程内,线程池内,带有返回的线程内执行
     */
    void execute(Runnable command);
}
```
2. 接下来ExecutorService接口继承了Executor接口，打开并摘取一部分重要的方法
```java
public interface ExecutorService extends Executor {
    // 线程池关闭，线程池里的线程就随它去
    void shutdown();
    
    //立刻停止！马上！正在执行的给我立马停！那些个没执行的返回来
    List<Runnable> shutdownNow();
    
    //判断线程池是不是被停了
    boolean isShutdown();

    //判断关闭（调用shutdown方法之后）线程池里面的线程是不是执行完了
    boolean isTerminated();

    //调用此方法之后就一直等待着线程池里面的线程执行完了之后，才能继续，两个参数控制等待的行为
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

     //好重要好重要的一个方法，用来提交有返回值的线程
    <T> Future<T> submit(Callable<T> task);

    //提交一个线程，指定一个结果，当线程完成的时候返回自定义的结果
    //相当于submit(Callable<T> task) 的另外一种实现
    <T> Future<T> submit(Runnable task, T result);

    //提交一个runnable 的线程，执行完了就返回null(Future.get()之后返回)
    //是不是觉得没啥意义~~意义当然有
    //返回的是一个Future，当调用get(),代码就会卡在那，等着返回
    //返回的即是是null,我也不care，目的只有“我知道这个任务已经结束了，可以开始下面的事情了”
    Future<?> submit(Runnable task);

    //相当于批量的submit(Callable<T> task)方法，一口气把想执行的callable task丢进线程池里面
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    //在批量提交的方法上增加时间相关的参数
    //如果超时，那么list里面的某个任务会被取消
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    //提交一大堆的线程，这么多线程里面一个成功就可以，只要给我一个返回值
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    //这个道理类似，就是在invokeAny(Collection<? extends Callable<T>> tasks) 上增加时间的控制
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```
3. 那么再然后就是AbstractExecutorService 这个类基本上实现了ExecutorService的行为，具体再细节的东西我们在他的子类里面详细的说
请记住这个男人 Doug Lea ！这个类就是这个人写的
4. 最重要的压轴类就是ThreadPoolExecutor，这个类继承了AbstractExecutorService类

## 2. ThreadPoolExecutor类的重要field

ThreadPoolExecutor类 是一个很大的类，里面的行为逻辑线条很多，因此在后期的说明中会辅以大量的流程图进行表示。

类的field的数量也多的吓人，因此在逻辑上我们先将全部的核心逻辑相关的field按照功能进行划分，一一击破即可。

### 按照功能划分-线程池的状态

 首先奉上各种线程池状态的迁移图及其关系

```java
    //AQS则只提供了state一个int型变量，此时将state高16位表示为读状态，低16位表示为写状态。这里的clt同样也是，它表示了两个概念：
    //1. workerCount：当前有效的线程数
    //2. runState：当前线程池的五种状态，Running、Shutdown、Stop、Tidying、Terminate。
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

    private static final int CAPACITY = (1 << COUNT_BITS) – 1;    //低29位表示最大线程数，229-1
    //定一个常量，在之后定义状态值是使用
    private static final int COUNT_BITS = Integer.SIZE - 3;         //32-3=29，线程数量所占位数

    //线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
    //线程池的初始化状态是RUNNING。当线程池被一旦被创建，就处于RUNNING状态，这个时候线程池中的任务数为0
    private static final int RUNNING    = -1 << COUNT_BITS; // int型变量高3位（含符号位）101表RUNING

    //如果调用了shutdown()方法，则线程池处于SHUTDOWN状态
    //线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
    private static final int SHUTDOWN   =  0 << COUNT_BITS; //高3位000

    //如果调用了shutdownNow()方法，则线程池处于STOP状态
    //线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
    private static final int STOP       =  1 << COUNT_BITS; ////高3位001

    //当所有的任务已终止，当前类记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()
    private static final int TIDYING    =  2 << COUNT_BITS; //高3位010

    //线程池彻底终止，就变成TERMINATED状态。 
    private static final int TERMINATED =  3 << COUNT_BITS; //高3位011

    //c & 高3位为1，低29位为0的~CAPACITY，用于获取高3位保存的线程池状态
    private static int runStateOf(int c)     { return c & ~CAPACITY; }
    //c & 高3位为0，低29位为1的CAPACITY，用于获取低29位的线程数量
    private static int workerCountOf(int c)  { return c & CAPACITY; }
    //参数rs表示runState，参数wc表示workerCount，即根据runState和workerCount打包合并成ctl
    private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 线程池的执行方法相关的核心field
还是先祭出一波所有的field列表
在这里面我们挑选重要的成员变量进行说明
```java
    //以下6个成员变量直接由构造方法传入
    //核心池的大小，当线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列
    private volatile int corePoolSize;                  //1
    private volatile int maximumPoolSize;               //2 线程池最大能容忍的线程数
    private final BlockingQueue<Runnable> workQueue;    //3 任务缓存队列，用来存放等待执行的任务
    private volatile long keepAliveTime;                //4 线程存活时间
    private volatile ThreadFactory threadFactory;       //5 线程工厂，用来创建线程
    private volatile RejectedExecutionHandler handler;  //6 任务拒绝策略

    private long completedTaskCount;        //用来记录已经执行完毕的任务个数
    private volatile int   poolSize;        //线程池中当前的线程数
    private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间
    private final HashSet<Worker> workers = new HashSet<Worker>();  //用来存放工作集
    private final ReentrantLock mainLock = new ReentrantLock();     //线程池的主要状态锁 很多方法强烈依赖于这个锁

```

### 线程池的辅助性支持field与inner class,一些相关的方法
```java


//用来存放工作集
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {...}
//以下四个inner类可以观察到都实现了RejectedExecutionHandler接口，这就是拒绝策略实体类
//是直接定义到ThreadPoolExecutor类内的
public static class CallerRunsPolicy implements RejectedExecutionHandler {...}
public static class AbortPolicy implements RejectedExecutionHandler {...}
public static class DiscardPolicy implements RejectedExecutionHandler {...}
public static class DiscardOldestPolicy implements RejectedExecutionHandler {...}
```

## ThreadPoolExecutor类构造方法
ThreadPoolExecutor类构造方法 的构造方法总共有四个，有些参数可以缺省，那么就用默认的代替，最终调用的就是下面所看到的构造方法
```java
    // 这些参数代表什么已经在上个小节内叨叨过了，在此不再重复，只关心构造函数内的逻辑
    // ThreadFactory 可以缺省，代替为Executors.defaultThreadFactory()
    // RejectedExecutionHandler 可以缺省 代替为 ThreadPoolExecutor.defaultHandler(内部类AbortPolicy的实例)
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,
                              TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        /**
         * 1. 检查数值型的入参是否符合要求
         * 2. 检查引用类型入参是否符合要求，只要一个null就抛异常
         * 3. 该赋值的就赋值，各回各家，各找爹妈
         * 4. keepAliveTime 通过TimeUnit(时间类型)和 keepAliveTime(时间数值)最终确定标准类型的时间长度
         * */
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
## 3. ThreadPoolExecutor类的核心方法(核心逻辑)
### 提交任务
从ExecutorService接口定义可以发现，提交任务的方式是有很多的，然而最终都和顶级接口定义的execute()方法分不开

因此我们以这个为突破口，刚好，前面小节内提供的小案例就是使用execute()方法提交的任务
```java
public void execute(Runnable command) {
        // 如果传入为空，则抛异常
        if (command == null)
            throw new NullPointerException();
        ////由它可以获取到当前有效的线程数和线程池的状态
        int c = ctl.get();
        //获取当前正在运行线程数是否小于核心线程池，是则新创建一个线程执行任务，否则将任务放到任务队列中
        //新建一个线程，赋给worker实例，worker线程调用command的run方法
        if (workerCountOf(c) < corePoolSize) { 
            //在addWorker中创建工作线程执行任务
            if (addWorker(command, true))             //.....addWorker方法 
                return;
            c = ctl.get();
        }
        //当前核心线程池中全部线程都在运行 -> workerCountOf(c) >= corePoolSize，所以此时将线程放到任务队列中
        //线程池是否处于运行状态，且是否任务插入任务队列成功
        if (isRunning(c) && workQueue.offer(command)) { //workQueue.offer 
            int recheck = ctl.get();
            //线程池是否处于运行状态，如果不是则使刚刚的任务出队
            if (! isRunning(recheck) && remove(command))
                //抛出RejectedExceptionException异常
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //插入队列不成功，且当前线程数数量小于最大线程池数量，此时则创建新线程执行任务，创建失败抛出异常
        else if (!addWorker(command, false))
            //抛出RejectedExceptionException异常
            reject(command);
    }
```
流程主逻辑有：

1. 如果线程池当前线程数量少于corePoolSize，则addWorker(command, true)创建新worker线程，如创建成功返回，如没创建成功，则执行后续步骤；
    addWorker(command, true)失败的原因可能是：
    A、线程池已经shutdown，shutdown的线程池不再接收新任务
    B、workerCountOf(c) < corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount>=corePoolSize
2. 如果线程池还在running状态，将task加入workQueue阻塞队列中，如果加入成功，进行double-check，如果加入失败（可能是队列已满），则执行后续步骤；
    double-check主要目的是判断刚加入workQueue阻塞队列的task是否能被执行
    A、如果线程池已经不是running状态了，应该拒绝添加新任务，从workQueue中删除任务
    B、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了）
3. 如果线程池不是running状态 或者 无法入队列，尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command

直接上个图！！！

从代码分析，addWorker方法是很重要的，多处被使用，查看此方法有
```java
/**
 * 此方法可以有四种形态
 * 1. addWorker(command, true)
 * 2. addWorker(command, false)
 * 3. addWorker(null, false)
 * 4. addWorker(null, true)
 *   第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false
 *   第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false
 *   第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务
 *   第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行
 *
 *
 *
 1、判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以return false：
    A、线程池状态>shutdown，可能为stop、tidying、terminated，不能添加worker线程
    B、线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务
    C、线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义
2、线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步
3、在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这一切都成功了，return true，如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑
 *
 *
 *
 *
 */

private boolean addWorker(Runnable firstTask, boolean core) {
        //外层循环，负责判断线程池状态
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 线程池的state越小越是运行状态，runnbale=-1，shutdown=0,stop=1,tidying=2，terminated=3
            //1、如果线程池state已经至少是shutdown状态了
            //2、并且以下3个条件任意一个是false
            //  rs == SHUTDOWN         （隐含：rs>=SHUTDOWN）false情况：线程池状态已经超过shutdown，可能是stop、tidying、terminated其中一个，即线程池已经终止
            //  firstTask == null      （隐含：rs==SHUTDOWN）false情况： firstTask不为空，rs==SHUTDOWN 且 firstTask不为空，return false，场景是在线程池已经shutdown后，还要添加新的任务，拒绝
            //  ! workQueue.isEmpty()  （隐含：rs==SHUTDOWN，firstTask==null）false情况： workQueue为空，当firstTask为空时是为了创建一个没有任务的线程，再从workQueue中获取任务，如果workQueue已经为空，那么就没有添加新worker线程的必要了
            // return false，即无法addWorker()
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            ////内层循环，负责worker数量+1
            for (;;) {
                int wc = workerCountOf(c);
                //如果worker数量>线程池最大上限CAPACITY（即使用int低29位可以容纳的最大值）
                //或者( worker数量>corePoolSize 或  worker数量>maximumPoolSize )，即已经超过了给定的边界
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                //调用unsafe CAS操作，使得worker数量+1，成功则跳出retry循环
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                //CAS worker数量+1失败，再次读取ctl
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS失败时因为workerCount改变了，继续内层循环尝试CAS对worker数量+1
            }
        }

        /**
     * worker数量+1成功的后续操作
     * 添加到workers Set集合，并启动worker线程
     */
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //1、设置worker这个AQS锁的同步状态state=-1
            //2、将firstTask设置给worker的成员变量firstTask
            //3、使用worker自身这个runnable，调用ThreadFactory创建一个线程，并设置给worker的成员变量thread
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    // 当获取到锁后，再次检查
                    int rs = runStateOf(ctl.get());

                    //如果线程池在运行running<shutdown 或者 线程池已经shutdown，且firstTask==null（可能是workQueue中仍有未执行完成的任务，创建没有初始任务的worker线程执行）
                    //worker数量-1的操作在addWorkerFailed()
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable   线程已经启动，抛非法线程状态异常
                            throw new IllegalThreadStateException();
                        //workers是一个HashSet<Worker>
                        workers.add(w);
                        //设置最大的池大小largestPoolSize，workerAdded设置为true
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                //如果往HashSet中添加worker成功，启动线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            //如果启动线程失败
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```































