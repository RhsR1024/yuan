# 死磕java多线程篇1 多线程开发的知识体系

学习是一个构建自己的知识体系树的过程。

树状结构那就要求每个节点都会和其他的节点发生关联。

新知识的纳入必然要和旧知识产生逻辑上的关联，不然就一点意思都没有了。

接下来，会详细的说明并发编程内的知识体系，以比较清晰的方式表达出来

此知识体系只会把逻辑上的关联性打通，而不会很具体去解释某一个部分

## 知识体系(目录形式)

### 1.并发编程的基本概念

1. 基本概念
    
    1. 同步/异步
    2. 并发/并行
    3. 阻塞/非阻塞
    4. 临界区资源

2. 关于引入并发编程
    
    1. 为什么要引入编发编程
    2. 并发编程的优点
    3. 并发编程的缺点

### 2. 线程池的状态及基本操作

1. 新建线程

    - 继承父类
    - 实现Runable接口
    - 时间Callable接口

2. 线程状态(生命周期)

    - 新建
    - 就绪
    - 运行
    - 阻塞
    - 死亡

3. 线程类本身的基本相关操作
    
    - 线程的类方法
        
        - 获取当前线程(currentThread)
        - 睡眠(sleep)
        - 让出cpu资源(yield)

    - 线程的实例方法
        
        - 启动线程
        - 中断线程(*)
        - 等待线程结束(join)
        - 改变为守护线程
        - 设置优先级别
    
    - 建立线程组

4. 并发理论(JMM)

    - JMM内存模型
    - 重排序
    - happens-before规则

5. 并发的三大特性与并发关键字

    - 三大特性
        
        - 原子性
        - 可见性
        - 有序性

    - 并发关键字
    
        - synchronized
        - volatile
        - final

6. 线程间通信

    - 共享内存的通信策略
    - 基于线程调度的通信
        
        - wait/notify/notifyAll
        - join
        - lock/condition的await() signal() signalAll()

7. 线程同步(协同步调)

    - lock体系
    - 并发容器
    - 原子操作类
    - 并发容器

8. 并发模式


### 针对目录的一些总体性的描述与概括

#### 基本概念

并发编程的引入是为了在相同的时间内干更多的事情，看上去很简单的想法实施起来就复杂的多了。

自然要引入并发编程，必然要引入并发编程的相关概念，不然无从说起。

那就自然而然的需要知道，并发是什么，为什么要用并发，有什么好处，又有什么坏处呢。

并发编程，类似于雇佣了好几个人干同样的事情，或者干着不一样的事情。反正一定意义上是协作关系。反观人类社会，从公司角度出发，公司的每个人时时刻刻都在和别人进行合作，进行协作，把公司做大做强。你就是ceo，你要负责把这些人协调好，公司办事效率自然会高。

再打个比方，在公司里，员工们的协作可以是这样的

  1.  有很多doc文件需要打印，当然有很多打印机的情况下，指派很多员工一起干，doc就可以分分钟被解决了
  2.  有一个事儿，必须先干A，然后再干B，然后再干C
  3.  有AB两个事儿，小黑同学一心二用，A做做B做做
  4.  向上级汇报了某个情况，必须等着领导回复，才能继续干和这个相关的事情
  5.  诸如此类。。。。

好像不会出现太大问题，现实生活中，总会有这样或者那样的解决方案，能够很好的解决我们面对的问题，再不济，天天问候对方父母即可。

然而，电脑是个蠢货，哪有那么机灵。当面对以上4个事情的时候，可能会遇到这样的问题。

  1. 我拿着A.doc去打印，小黑也拿着A.doc去打印，最终打印了两份。会被人骂死的
  2. 我哪管你ABC，一起干了呗，为什么要等着A完了之后再干B？
  3. 电脑发现做A要用到B，就跑去做B，B做着做着又发现要做A诶，那不是就惨了，我哪知道要做哪个
  4. 电脑太傻了，为什么要等着呢？我干干其他的不相关的事情不行吗？非要等着？

以上可能也只是部分的例子。这表明协作办公可能并不是一个特别简单的事情。

在开发领域为了解决这些问题，第一步就是明确化各种定义，引入各种概念。(更细节的请参考网络，相信肯定能查到很多)

#### 线程基本操作

我们要理解更深层次的东西的话，先入个门吧，至少线程怎么玩。

这里会有几个知识点，对付对付一般的工作，差不都够了哦，但是，好歹有些追求诶 ：）

1. 创建线程，并让这些线程run起来
2. 两个线程之间是需要协作的，怎么协作？比方说A和B线程，这俩都要cpu给些资源然后run起来，可能会出现以下情况（不是全部）
    
    - A说：B诶，你给我等着啊，我先干完你再干
    - A说：B诶，我差不多要干完啦，我先让你干干啊，你干完再告诉我一声啊
    - A说：B诶，我懒死了，我要先睡一会儿啊，你爱咋地咋地
    - A说：B诶，我要插个队啊，我管你咋的，我就要插个队啊，我先啊，你让让（优先级）

3. 以上协作的过程伴随着线程本身的生命周期发生变化（请一定要上网查找这个生命周期图，在此不予解释）

#### 并发理论

1. 这个部分很学术，主要是jvm层的一些与线程相关的知识
2. jvm中与并发扯上关系的部分大体上可以分为三个部分

    - JMM内存模型
    - JVM的指令重排
    - happens-before规则（JVM保证无论线程间指令怎么重排，这里的规则始终保证）

什么是JMM内存模型？

第一步要了解的就是硬件内存模型，硬件上cpu与多级缓存之间的关系与协作，而此协作方式会导致伪共享问题发生

第二部就可以了解到Java内存模型，线程、工作内存、主内存之间的关系以及其对应jvm的部分

为什么要了解JMM内存模型？

因为JMM内存模型是为了解决多线程环境下共享变量一致性问题的，这个地方就需要引入三大特性：

1. 原子性 : 一系列操作要么成功要么失败，类似于数据库的事务操作
2. 可见性 : 线程对值修改，所有的其他线程立刻感知
3. 有序性 : 防止jvm指令重排导致

可以这么说，所有的线程相关类或多或少都是为了满足这三个特性展开的。


